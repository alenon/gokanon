
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>aianalyzer: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/alenon/gokanon/internal/aianalyzer/aianalyzer.go (62.0%)</option>
				
				<option value="file1">github.com/alenon/gokanon/internal/aianalyzer/prompts.go (98.4%)</option>
				
				<option value="file2">github.com/alenon/gokanon/internal/aianalyzer/providers.go (0.0%)</option>
				
				<option value="file3">github.com/alenon/gokanon/internal/cli/cli.go (0.0%)</option>
				
				<option value="file4">github.com/alenon/gokanon/internal/cli/commands/baseline.go (24.8%)</option>
				
				<option value="file5">github.com/alenon/gokanon/internal/cli/commands/check.go (28.9%)</option>
				
				<option value="file6">github.com/alenon/gokanon/internal/cli/commands/compare.go (22.8%)</option>
				
				<option value="file7">github.com/alenon/gokanon/internal/cli/commands/completion.go (79.5%)</option>
				
				<option value="file8">github.com/alenon/gokanon/internal/cli/commands/delete.go (100.0%)</option>
				
				<option value="file9">github.com/alenon/gokanon/internal/cli/commands/doctor.go (83.3%)</option>
				
				<option value="file10">github.com/alenon/gokanon/internal/cli/commands/export.go (27.3%)</option>
				
				<option value="file11">github.com/alenon/gokanon/internal/cli/commands/flamegraph.go (37.9%)</option>
				
				<option value="file12">github.com/alenon/gokanon/internal/cli/commands/interactive.go (0.0%)</option>
				
				<option value="file13">github.com/alenon/gokanon/internal/cli/commands/list.go (94.1%)</option>
				
				<option value="file14">github.com/alenon/gokanon/internal/cli/commands/run.go (0.0%)</option>
				
				<option value="file15">github.com/alenon/gokanon/internal/cli/commands/serve.go (0.0%)</option>
				
				<option value="file16">github.com/alenon/gokanon/internal/cli/commands/stats.go (96.4%)</option>
				
				<option value="file17">github.com/alenon/gokanon/internal/cli/commands/trend.go (85.2%)</option>
				
				<option value="file18">github.com/alenon/gokanon/internal/compare/compare.go (100.0%)</option>
				
				<option value="file19">github.com/alenon/gokanon/internal/dashboard/server.go (83.9%)</option>
				
				<option value="file20">github.com/alenon/gokanon/internal/doctor/doctor.go (92.6%)</option>
				
				<option value="file21">github.com/alenon/gokanon/internal/export/export.go (91.8%)</option>
				
				<option value="file22">github.com/alenon/gokanon/internal/interactive/interactive.go (53.1%)</option>
				
				<option value="file23">github.com/alenon/gokanon/internal/profiler/profiler.go (80.1%)</option>
				
				<option value="file24">github.com/alenon/gokanon/internal/runner/runner.go (83.0%)</option>
				
				<option value="file25">github.com/alenon/gokanon/internal/stats/stats.go (100.0%)</option>
				
				<option value="file26">github.com/alenon/gokanon/internal/storage/storage.go (89.5%)</option>
				
				<option value="file27">github.com/alenon/gokanon/internal/threshold/threshold.go (100.0%)</option>
				
				<option value="file28">github.com/alenon/gokanon/internal/ui/colors.go (100.0%)</option>
				
				<option value="file29">github.com/alenon/gokanon/internal/ui/errors.go (89.7%)</option>
				
				<option value="file30">github.com/alenon/gokanon/internal/ui/progress.go (84.3%)</option>
				
				<option value="file31">github.com/alenon/gokanon/internal/webserver/server.go (55.6%)</option>
				
				<option value="file32">github.com/alenon/gokanon/main.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package aianalyzer

import (
        "encoding/json"
        "fmt"
        "os"

        "github.com/alenon/gokanon/internal/models"
)

// Config holds AI analyzer configuration
type Config struct {
        Enabled  bool
        Provider string // "ollama" or "groq"
        Model    string // Model name to use
        APIKey   string // API key for cloud providers (not needed for Ollama)
        BaseURL  string // Base URL for the provider
}

// Analyzer provides AI-powered analysis of benchmark results
type Analyzer struct {
        config   Config
        provider AIProvider
}

// NewAnalyzer creates a new AI analyzer
func NewAnalyzer(config Config) (*Analyzer, error) <span class="cov7" title="4">{
        if !config.Enabled </span><span class="cov5" title="3">{
                return &amp;Analyzer{config: config}, nil
        }</span>

        <span class="cov1" title="1">var provider AIProvider
        var err error

        switch config.Provider </span>{
        case "ollama":<span class="cov0" title="0">
                provider, err = NewOllamaProvider(config)</span>
        case "groq":<span class="cov0" title="0">
                provider, err = NewGroqProvider(config)</span>
        case "openai":<span class="cov0" title="0">
                provider, err = NewOpenAIProvider(config)</span>
        case "anthropic", "claude":<span class="cov0" title="0">
                provider, err = NewAnthropicProvider(config)</span>
        case "gemini":<span class="cov0" title="0">
                provider, err = NewGeminiProvider(config)</span>
        case "openai-compatible", "custom":<span class="cov0" title="0">
                provider, err = NewOpenAICompatibleProvider(config)</span>
        default:<span class="cov1" title="1">
                return nil, fmt.Errorf("unsupported AI provider: %s (supported: ollama, groq, openai, anthropic, gemini, openai-compatible)", config.Provider)</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to initialize AI provider: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;Analyzer{
                config:   config,
                provider: provider,
        }, nil</span>
}

// NewFromEnv creates an analyzer from environment variables
func NewFromEnv() (*Analyzer, error) <span class="cov4" title="2">{
        config := Config{
                Enabled:  os.Getenv("GOKANON_AI_ENABLED") == "true",
                Provider: getEnvWithDefault("GOKANON_AI_PROVIDER", "ollama"),
                Model:    getEnvWithDefault("GOKANON_AI_MODEL", ""),
                APIKey:   os.Getenv("GOKANON_AI_API_KEY"),
                BaseURL:  getEnvWithDefault("GOKANON_AI_BASE_URL", ""),
        }

        // Set default models if not specified
        if config.Model == "" </span><span class="cov1" title="1">{
                switch config.Provider </span>{
                case "ollama":<span class="cov1" title="1">
                        config.Model = "llama3.2"</span>
                case "groq":<span class="cov0" title="0">
                        config.Model = "llama-3.3-70b-versatile"</span>
                case "openai":<span class="cov0" title="0">
                        config.Model = "gpt-4o"</span>
                case "anthropic", "claude":<span class="cov0" title="0">
                        config.Model = "claude-sonnet-4-5-20250929"</span>
                case "gemini":<span class="cov0" title="0">
                        config.Model = "gemini-2.5-flash"</span>
                case "openai-compatible", "custom":<span class="cov0" title="0">
                        config.Model = "default"</span> // Let the service use its default model
                }
        }

        // Set default base URLs if not specified
        <span class="cov4" title="2">if config.BaseURL == "" </span><span class="cov4" title="2">{
                switch config.Provider </span>{
                case "ollama":<span class="cov1" title="1">
                        config.BaseURL = "http://localhost:11434"</span>
                case "groq":<span class="cov1" title="1">
                        config.BaseURL = "https://api.groq.com/openai/v1"</span>
                case "openai":<span class="cov0" title="0">
                        config.BaseURL = "https://api.openai.com"</span>
                case "anthropic", "claude":<span class="cov0" title="0">
                        config.BaseURL = "https://api.anthropic.com"</span>
                case "gemini":<span class="cov0" title="0">
                        config.BaseURL = "https://generativelanguage.googleapis.com"</span>
                case "openai-compatible", "custom":<span class="cov0" title="0">
                        config.BaseURL = "http://localhost:8080"</span> // Placeholder, should be set by user
                }
        }

        <span class="cov4" title="2">return NewAnalyzer(config)</span>
}

// EnhanceProfileSummary enhances a profile summary with AI insights
func (a *Analyzer) EnhanceProfileSummary(summary *models.ProfileSummary) (*models.ProfileSummary, error) <span class="cov4" title="2">{
        if !a.config.Enabled || a.provider == nil </span><span class="cov1" title="1">{
                return summary, nil
        }</span>

        // Prepare context for AI
        <span class="cov1" title="1">context, err := a.prepareProfileContext(summary)
        if err != nil </span><span class="cov0" title="0">{
                return summary, fmt.Errorf("failed to prepare context: %w", err)
        }</span>

        // Get AI analysis
        <span class="cov1" title="1">prompt := buildProfileAnalysisPrompt(context)
        response, err := a.provider.Analyze(prompt)
        if err != nil </span><span class="cov0" title="0">{
                return summary, fmt.Errorf("AI analysis failed: %w", err)
        }</span>

        // Parse AI response and enhance suggestions
        <span class="cov1" title="1">enhancedSuggestions, err := a.parseAISuggestions(response, summary)
        if err != nil </span><span class="cov0" title="0">{
                // If parsing fails, keep original suggestions
                return summary, fmt.Errorf("failed to parse AI suggestions: %w", err)
        }</span>

        // Create enhanced summary
        <span class="cov1" title="1">enhanced := *summary
        enhanced.Suggestions = enhancedSuggestions
        return &amp;enhanced, nil</span>
}

// AnalyzeComparison provides AI insights on benchmark comparison
func (a *Analyzer) AnalyzeComparison(oldRun, newRun *models.BenchmarkRun, comparisons []models.Comparison) (string, error) <span class="cov4" title="2">{
        if !a.config.Enabled || a.provider == nil </span><span class="cov1" title="1">{
                return "", nil
        }</span>

        // Prepare comparison context
        <span class="cov1" title="1">context := a.prepareComparisonContext(oldRun, newRun, comparisons)

        // Get AI analysis
        prompt := buildComparisonAnalysisPrompt(context)
        response, err := a.provider.Analyze(prompt)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("AI comparison analysis failed: %w", err)
        }</span>

        <span class="cov1" title="1">return response, nil</span>
}

// prepareProfileContext converts profile summary to AI-friendly format
func (a *Analyzer) prepareProfileContext(summary *models.ProfileSummary) (string, error) <span class="cov4" title="2">{
        context := map[string]interface{}{
                "cpu_top_functions":    summary.CPUTopFunctions,
                "memory_top_functions": summary.MemoryTopFunctions,
                "memory_leaks":         summary.MemoryLeaks,
                "hot_paths":            summary.HotPaths,
                "total_cpu_samples":    summary.TotalCPUSamples,
                "total_memory_bytes":   summary.TotalMemoryBytes,
                "existing_suggestions": summary.Suggestions,
        }

        data, err := json.MarshalIndent(context, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov4" title="2">return string(data), nil</span>
}

// prepareComparisonContext converts comparison data to AI-friendly format
func (a *Analyzer) prepareComparisonContext(oldRun, newRun *models.BenchmarkRun, comparisons []models.Comparison) string <span class="cov4" title="2">{
        context := map[string]interface{}{
                "old_run": map[string]interface{}{
                        "timestamp":  oldRun.Timestamp,
                        "go_version": oldRun.GoVersion,
                        "package":    oldRun.Package,
                },
                "new_run": map[string]interface{}{
                        "timestamp":  newRun.Timestamp,
                        "go_version": newRun.GoVersion,
                        "package":    newRun.Package,
                },
                "comparisons": comparisons,
        }

        data, _ := json.MarshalIndent(context, "", "  ")
        return string(data)
}</span>

// parseAISuggestions parses AI response and merges with existing suggestions
func (a *Analyzer) parseAISuggestions(aiResponse string, summary *models.ProfileSummary) ([]models.Suggestion, error) <span class="cov1" title="1">{
        // Try to parse as JSON array first
        var aiSuggestions []models.Suggestion
        if err := json.Unmarshal([]byte(aiResponse), &amp;aiSuggestions); err == nil </span><span class="cov1" title="1">{
                // Merge AI suggestions with existing ones
                return a.mergeSuggestions(summary.Suggestions, aiSuggestions), nil
        }</span>

        // If not JSON, try to extract structured suggestions from markdown/text
        <span class="cov0" title="0">parsed := parseTextSuggestions(aiResponse)
        if len(parsed) &gt; 0 </span><span class="cov0" title="0">{
                return a.mergeSuggestions(summary.Suggestions, parsed), nil
        }</span>

        // If we can't parse, add the raw AI response as a general suggestion
        <span class="cov0" title="0">if aiResponse != "" </span><span class="cov0" title="0">{
                general := models.Suggestion{
                        Type:       "general",
                        Severity:   "info",
                        Function:   "Overall Analysis",
                        Issue:      "AI Analysis Results",
                        Suggestion: aiResponse,
                        Impact:     "See detailed analysis above",
                }
                return append(summary.Suggestions, general), nil
        }</span>

        <span class="cov0" title="0">return summary.Suggestions, nil</span>
}

// mergeSuggestions combines original and AI suggestions, removing duplicates
func (a *Analyzer) mergeSuggestions(original, ai []models.Suggestion) []models.Suggestion <span class="cov1" title="1">{
        // Use a map to track suggestions by function+type to avoid duplicates
        seen := make(map[string]bool)
        var merged []models.Suggestion

        // Add original suggestions first
        for _, s := range original </span><span class="cov0" title="0">{
                key := fmt.Sprintf("%s:%s", s.Function, s.Type)
                if !seen[key] </span><span class="cov0" title="0">{
                        merged = append(merged, s)
                        seen[key] = true
                }</span>
        }

        // Add AI suggestions, skipping duplicates
        <span class="cov1" title="1">for _, s := range ai </span><span class="cov1" title="1">{
                key := fmt.Sprintf("%s:%s", s.Function, s.Type)
                if !seen[key] </span><span class="cov1" title="1">{
                        // Mark AI-enhanced suggestions
                        if s.Impact == "" </span><span class="cov0" title="0">{
                                s.Impact = "AI-suggested optimization"
                        }</span>
                        <span class="cov1" title="1">merged = append(merged, s)
                        seen[key] = true</span>
                }
        }

        <span class="cov1" title="1">return merged</span>
}

// getEnvWithDefault gets environment variable with a default value
func getEnvWithDefault(key, defaultValue string) string <span class="cov10" title="8">{
        if value := os.Getenv(key); value != "" </span><span class="cov7" title="4">{
                return value
        }</span>
        <span class="cov7" title="4">return defaultValue</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package aianalyzer

import (
        "encoding/json"
        "fmt"
        "regexp"
        "strings"

        "github.com/alenon/gokanon/internal/models"
)

// buildProfileAnalysisPrompt creates a prompt for profile analysis
func buildProfileAnalysisPrompt(context string) string <span class="cov2" title="2">{
        return fmt.Sprintf(`You are analyzing Go benchmark profiling data. Based on the data below, provide optimization suggestions.

PROFILING DATA:
%s

Please analyze this data and provide actionable optimization suggestions. For each suggestion, provide:
1. Type: "cpu", "memory", or "algorithm"
2. Severity: "low", "medium", or "high"
3. Function: The affected function name
4. Issue: A brief description of the problem
5. Suggestion: Specific, actionable advice on how to fix it
6. Impact: Expected performance improvement

Respond with a JSON array of suggestions in this format:
[
  {
    "type": "cpu",
    "severity": "high",
    "function": "functionName",
    "issue": "Brief issue description",
    "suggestion": "Specific actionable advice",
    "impact": "Expected improvement description"
  }
]

Focus on the most impactful optimizations. Consider:
- Hot functions consuming significant CPU/memory
- Potential memory leaks (high allocation with low in-use memory)
- Hot paths that could be optimized
- Common Go performance patterns (e.g., unnecessary allocations, inefficient algorithms)
- Opportunities for sync.Pool, buffering, or pre-allocation

Be specific and actionable in your suggestions.`, context)
}</span>

// buildComparisonAnalysisPrompt creates a prompt for comparison analysis
func buildComparisonAnalysisPrompt(context string) string <span class="cov2" title="2">{
        return fmt.Sprintf(`You are analyzing benchmark comparison results between two Go benchmark runs.

COMPARISON DATA:
%s

Please analyze the performance changes and provide insights about:
1. Significant improvements or regressions
2. Possible causes for the changes
3. Whether the changes are concerning or expected
4. Recommendations for next steps

Provide a concise analysis (2-3 paragraphs) focusing on the most important findings.`, context)
}</span>

// parseTextSuggestions attempts to parse suggestions from markdown/text format
func parseTextSuggestions(text string) []models.Suggestion <span class="cov5" title="6">{
        var suggestions []models.Suggestion

        // Try to extract JSON blocks from markdown
        jsonBlockRegex := regexp.MustCompile("```(?:json)?\n(\\[\\s*\\{[\\s\\S]*?\\}\\s*\\])\\n```")
        matches := jsonBlockRegex.FindStringSubmatch(text)
        if len(matches) &gt; 1 </span><span class="cov2" title="2">{
                var parsed []models.Suggestion
                if err := json.Unmarshal([]byte(matches[1]), &amp;parsed); err == nil </span><span class="cov2" title="2">{
                        return parsed
                }</span>
        }

        // Try to find JSON array directly in text
        <span class="cov4" title="4">jsonArrayRegex := regexp.MustCompile(`\[\s*\{[^\]]*"type"\s*:[^\]]*"suggestion"\s*:[^\]]*\}\s*\]`)
        match := jsonArrayRegex.FindString(text)
        if match != "" </span><span class="cov1" title="1">{
                var parsed []models.Suggestion
                if err := json.Unmarshal([]byte(match), &amp;parsed); err == nil </span><span class="cov1" title="1">{
                        return parsed
                }</span>
        }

        // If no structured format found, try to extract bullet points
        <span class="cov4" title="3">suggestions = extractBulletSuggestions(text)
        if len(suggestions) &gt; 0 </span><span class="cov1" title="1">{
                return suggestions
        }</span>

        <span class="cov2" title="2">return nil</span>
}

// extractBulletSuggestions extracts suggestions from bullet-point format
func extractBulletSuggestions(text string) []models.Suggestion <span class="cov7" title="10">{
        var suggestions []models.Suggestion

        // Common bullet point patterns
        lines := strings.Split(text, "\n")
        var currentSuggestion *models.Suggestion

        for _, line := range lines </span><span class="cov10" title="26">{
                line = strings.TrimSpace(line)
                if line == "" </span><span class="cov4" title="4">{
                        continue</span>
                }

                // Check for bullet points or numbered lists
                <span class="cov9" title="22">if strings.HasPrefix(line, "-") || strings.HasPrefix(line, "*") ||
                        regexp.MustCompile(`^\d+\.`).MatchString(line) </span><span class="cov8" title="17">{
                        // Save previous suggestion if exists
                        if currentSuggestion != nil </span><span class="cov7" title="10">{
                                suggestions = append(suggestions, *currentSuggestion)
                        }</span>

                        // Start new suggestion
                        <span class="cov8" title="17">cleaned := regexp.MustCompile(`^[-*\d.]\s*`).ReplaceAllString(line, "")
                        currentSuggestion = &amp;models.Suggestion{
                                Type:       inferType(cleaned),
                                Severity:   inferSeverity(cleaned),
                                Function:   extractFunction(cleaned),
                                Issue:      extractIssue(cleaned),
                                Suggestion: cleaned,
                                Impact:     "Potential performance improvement",
                        }</span>
                } else<span class="cov5" title="5"> if currentSuggestion != nil </span><span class="cov4" title="3">{
                        // Continuation of current suggestion
                        currentSuggestion.Suggestion += " " + line
                }</span>
        }

        // Add last suggestion
        <span class="cov7" title="10">if currentSuggestion != nil </span><span class="cov6" title="7">{
                suggestions = append(suggestions, *currentSuggestion)
        }</span>

        <span class="cov7" title="10">return suggestions</span>
}

// inferType tries to infer the suggestion type from text
func inferType(text string) string <span class="cov9" title="25">{
        lower := strings.ToLower(text)
        if strings.Contains(lower, "cpu") || strings.Contains(lower, "time") ||
                strings.Contains(lower, "slow") || strings.Contains(lower, "performance") </span><span class="cov4" title="4">{
                return "cpu"
        }</span>
        <span class="cov9" title="21">if strings.Contains(lower, "memory") || strings.Contains(lower, "allocation") ||
                strings.Contains(lower, "leak") || strings.Contains(lower, "gc") </span><span class="cov5" title="5">{
                return "memory"
        }</span>
        <span class="cov8" title="16">if strings.Contains(lower, "algorithm") || strings.Contains(lower, "complexity") </span><span class="cov1" title="1">{
                return "algorithm"
        }</span>
        <span class="cov8" title="15">return "general"</span>
}

// inferSeverity tries to infer severity from text
func inferSeverity(text string) string <span class="cov9" title="24">{
        lower := strings.ToLower(text)
        if strings.Contains(lower, "critical") || strings.Contains(lower, "severe") ||
                strings.Contains(lower, "major") </span><span class="cov4" title="3">{
                return "high"
        }</span>
        <span class="cov9" title="21">if strings.Contains(lower, "moderate") || strings.Contains(lower, "significant") </span><span class="cov2" title="2">{
                return "medium"
        }</span>
        <span class="cov9" title="19">return "low"</span>
}

// extractFunction tries to extract function name from text
func extractFunction(text string) string <span class="cov9" title="22">{
        // Look for common function patterns
        funcRegex := regexp.MustCompile(`(\w+(?:\.\w+)*)\s*\(`)
        if match := funcRegex.FindStringSubmatch(text); len(match) &gt; 1 </span><span class="cov2" title="2">{
                return match[1]
        }</span>

        // Look for backtick-quoted names
        <span class="cov9" title="20">backtickRegex := regexp.MustCompile("`([^`]+)`")
        if match := backtickRegex.FindStringSubmatch(text); len(match) &gt; 1 </span><span class="cov1" title="1">{
                return match[1]
        }</span>

        <span class="cov9" title="19">return "General"</span>
}

// extractIssue tries to extract the issue description
func extractIssue(text string) string <span class="cov9" title="21">{
        // Split on common delimiters
        parts := regexp.MustCompile(`[:|-]`).Split(text, 2)
        if len(parts) &gt; 0 </span><span class="cov9" title="21">{
                issue := strings.TrimSpace(parts[0])
                if len(issue) &gt; 100 </span><span class="cov1" title="1">{
                        return issue[:97] + "..."
                }</span>
                <span class="cov9" title="20">return issue</span>
        }
        <span class="cov0" title="0">return "Performance issue detected"</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package aianalyzer

import (
        "bytes"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "time"
)

// AIProvider is the interface for AI service providers
type AIProvider interface {
        Analyze(prompt string) (string, error)
}

// OllamaProvider implements AIProvider for Ollama
type OllamaProvider struct {
        baseURL string
        model   string
        client  *http.Client
}

// NewOllamaProvider creates a new Ollama provider
func NewOllamaProvider(config Config) (*OllamaProvider, error) <span class="cov0" title="0">{
        return &amp;OllamaProvider{
                baseURL: config.BaseURL,
                model:   config.Model,
                client: &amp;http.Client{
                        Timeout: 60 * time.Second,
                },
        }, nil
}</span>

// Analyze sends a prompt to Ollama and returns the response
func (p *OllamaProvider) Analyze(prompt string) (string, error) <span class="cov0" title="0">{
        requestBody := map[string]interface{}{
                "model":  p.model,
                "prompt": prompt,
                "stream": false,
                "options": map[string]interface{}{
                        "temperature": 0.7,
                        "top_p":       0.9,
                },
        }

        jsonData, err := json.Marshal(requestBody)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to marshal request: %w", err)
        }</span>

        <span class="cov0" title="0">url := fmt.Sprintf("%s/api/generate", p.baseURL)
        resp, err := p.client.Post(url, "application/json", bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to send request to Ollama: %w (is Ollama running? try: ollama serve)", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return "", fmt.Errorf("Ollama API error (status %d): %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">var response struct {
                Response string `json:"response"`
        }

        if err := json.NewDecoder(resp.Body).Decode(&amp;response); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to decode Ollama response: %w", err)
        }</span>

        <span class="cov0" title="0">return response.Response, nil</span>
}

// GroqProvider implements AIProvider for Groq
type GroqProvider struct {
        baseURL string
        model   string
        apiKey  string
        client  *http.Client
}

// NewGroqProvider creates a new Groq provider
func NewGroqProvider(config Config) (*GroqProvider, error) <span class="cov0" title="0">{
        if config.APIKey == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Groq API key is required (set GOKANON_AI_API_KEY environment variable)")
        }</span>

        <span class="cov0" title="0">return &amp;GroqProvider{
                baseURL: config.BaseURL,
                model:   config.Model,
                apiKey:  config.APIKey,
                client: &amp;http.Client{
                        Timeout: 60 * time.Second,
                },
        }, nil</span>
}

// Analyze sends a prompt to Groq and returns the response
func (p *GroqProvider) Analyze(prompt string) (string, error) <span class="cov0" title="0">{
        requestBody := map[string]interface{}{
                "model": p.model,
                "messages": []map[string]string{
                        {
                                "role":    "system",
                                "content": "You are an expert Go performance analyst. Provide concise, actionable insights about benchmark results.",
                        },
                        {
                                "role":    "user",
                                "content": prompt,
                        },
                },
                "temperature": 0.7,
                "max_tokens":  2000,
        }

        jsonData, err := json.Marshal(requestBody)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to marshal request: %w", err)
        }</span>

        <span class="cov0" title="0">url := fmt.Sprintf("%s/chat/completions", p.baseURL)
        req, err := http.NewRequest("POST", url, bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Authorization", fmt.Sprintf("Bearer %s", p.apiKey))

        resp, err := p.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to send request to Groq: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return "", fmt.Errorf("Groq API error (status %d): %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">var response struct {
                Choices []struct {
                        Message struct {
                                Content string `json:"content"`
                        } `json:"message"`
                } `json:"choices"`
        }

        if err := json.NewDecoder(resp.Body).Decode(&amp;response); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to decode Groq response: %w", err)
        }</span>

        <span class="cov0" title="0">if len(response.Choices) == 0 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no response from Groq")
        }</span>

        <span class="cov0" title="0">return response.Choices[0].Message.Content, nil</span>
}

// OpenAIProvider implements AIProvider for OpenAI (GPT-4o, GPT-4-turbo, etc.)
type OpenAIProvider struct {
        baseURL string
        model   string
        apiKey  string
        client  *http.Client
}

// NewOpenAIProvider creates a new OpenAI provider
func NewOpenAIProvider(config Config) (*OpenAIProvider, error) <span class="cov0" title="0">{
        if config.APIKey == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("OpenAI API key is required (set GOKANON_AI_API_KEY environment variable)")
        }</span>

        <span class="cov0" title="0">return &amp;OpenAIProvider{
                baseURL: config.BaseURL,
                model:   config.Model,
                apiKey:  config.APIKey,
                client: &amp;http.Client{
                        Timeout: 60 * time.Second,
                },
        }, nil</span>
}

// Analyze sends a prompt to OpenAI and returns the response
func (p *OpenAIProvider) Analyze(prompt string) (string, error) <span class="cov0" title="0">{
        requestBody := map[string]interface{}{
                "model": p.model,
                "messages": []map[string]string{
                        {
                                "role":    "system",
                                "content": "You are an expert Go performance analyst. Provide concise, actionable insights about benchmark results.",
                        },
                        {
                                "role":    "user",
                                "content": prompt,
                        },
                },
                "temperature": 0.7,
                "max_tokens":  2000,
        }

        jsonData, err := json.Marshal(requestBody)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to marshal request: %w", err)
        }</span>

        <span class="cov0" title="0">url := fmt.Sprintf("%s/v1/chat/completions", p.baseURL)
        req, err := http.NewRequest("POST", url, bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Authorization", fmt.Sprintf("Bearer %s", p.apiKey))

        resp, err := p.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to send request to OpenAI: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return "", fmt.Errorf("OpenAI API error (status %d): %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">var response struct {
                Choices []struct {
                        Message struct {
                                Content string `json:"content"`
                        } `json:"message"`
                } `json:"choices"`
        }

        if err := json.NewDecoder(resp.Body).Decode(&amp;response); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to decode OpenAI response: %w", err)
        }</span>

        <span class="cov0" title="0">if len(response.Choices) == 0 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no response from OpenAI")
        }</span>

        <span class="cov0" title="0">return response.Choices[0].Message.Content, nil</span>
}

// AnthropicProvider implements AIProvider for Anthropic Claude (Sonnet 4.5, Haiku 4.5, etc.)
type AnthropicProvider struct {
        baseURL string
        model   string
        apiKey  string
        client  *http.Client
}

// NewAnthropicProvider creates a new Anthropic provider
func NewAnthropicProvider(config Config) (*AnthropicProvider, error) <span class="cov0" title="0">{
        if config.APIKey == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Anthropic API key is required (set GOKANON_AI_API_KEY environment variable)")
        }</span>

        <span class="cov0" title="0">return &amp;AnthropicProvider{
                baseURL: config.BaseURL,
                model:   config.Model,
                apiKey:  config.APIKey,
                client: &amp;http.Client{
                        Timeout: 60 * time.Second,
                },
        }, nil</span>
}

// Analyze sends a prompt to Anthropic and returns the response
func (p *AnthropicProvider) Analyze(prompt string) (string, error) <span class="cov0" title="0">{
        requestBody := map[string]interface{}{
                "model":      p.model,
                "max_tokens": 2000,
                "messages": []map[string]string{
                        {
                                "role":    "user",
                                "content": prompt,
                        },
                },
                "system": "You are an expert Go performance analyst. Provide concise, actionable insights about benchmark results.",
        }

        jsonData, err := json.Marshal(requestBody)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to marshal request: %w", err)
        }</span>

        <span class="cov0" title="0">url := fmt.Sprintf("%s/v1/messages", p.baseURL)
        req, err := http.NewRequest("POST", url, bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("x-api-key", p.apiKey)
        req.Header.Set("anthropic-version", "2023-06-01")

        resp, err := p.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to send request to Anthropic: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return "", fmt.Errorf("Anthropic API error (status %d): %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">var response struct {
                Content []struct {
                        Type string `json:"type"`
                        Text string `json:"text"`
                } `json:"content"`
        }

        if err := json.NewDecoder(resp.Body).Decode(&amp;response); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to decode Anthropic response: %w", err)
        }</span>

        <span class="cov0" title="0">if len(response.Content) == 0 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no response from Anthropic")
        }</span>

        // Concatenate all text blocks
        <span class="cov0" title="0">var result string
        for _, content := range response.Content </span><span class="cov0" title="0">{
                if content.Type == "text" </span><span class="cov0" title="0">{
                        result += content.Text
                }</span>
        }

        <span class="cov0" title="0">if result == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no text content in Anthropic response")
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// OpenAICompatibleProvider implements AIProvider for OpenAI-compatible endpoints
// This works with any service that implements the OpenAI Chat Completions API format,
// including Cursor, LM Studio, LocalAI, and many other services
type OpenAICompatibleProvider struct {
        baseURL string
        model   string
        apiKey  string
        client  *http.Client
}

// NewOpenAICompatibleProvider creates a new OpenAI-compatible provider
func NewOpenAICompatibleProvider(config Config) (*OpenAICompatibleProvider, error) <span class="cov0" title="0">{
        // API key is optional for some local services
        return &amp;OpenAICompatibleProvider{
                baseURL: config.BaseURL,
                model:   config.Model,
                apiKey:  config.APIKey,
                client: &amp;http.Client{
                        Timeout: 60 * time.Second,
                },
        }, nil
}</span>

// Analyze sends a prompt to an OpenAI-compatible endpoint and returns the response
func (p *OpenAICompatibleProvider) Analyze(prompt string) (string, error) <span class="cov0" title="0">{
        requestBody := map[string]interface{}{
                "model": p.model,
                "messages": []map[string]string{
                        {
                                "role":    "system",
                                "content": "You are an expert Go performance analyst. Provide concise, actionable insights about benchmark results.",
                        },
                        {
                                "role":    "user",
                                "content": prompt,
                        },
                },
                "temperature": 0.7,
                "max_tokens":  2000,
        }

        jsonData, err := json.Marshal(requestBody)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to marshal request: %w", err)
        }</span>

        // Try both with and without /v1 prefix
        <span class="cov0" title="0">url := fmt.Sprintf("%s/chat/completions", p.baseURL)
        if !bytes.Contains([]byte(p.baseURL), []byte("/v1")) </span><span class="cov0" title="0">{
                url = fmt.Sprintf("%s/v1/chat/completions", p.baseURL)
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest("POST", url, bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")
        if p.apiKey != "" </span><span class="cov0" title="0">{
                req.Header.Set("Authorization", fmt.Sprintf("Bearer %s", p.apiKey))
        }</span>

        <span class="cov0" title="0">resp, err := p.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to send request to OpenAI-compatible endpoint: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return "", fmt.Errorf("OpenAI-compatible API error (status %d): %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">var response struct {
                Choices []struct {
                        Message struct {
                                Content string `json:"content"`
                        } `json:"message"`
                } `json:"choices"`
        }

        if err := json.NewDecoder(resp.Body).Decode(&amp;response); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to decode response: %w", err)
        }</span>

        <span class="cov0" title="0">if len(response.Choices) == 0 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no response from OpenAI-compatible endpoint")
        }</span>

        <span class="cov0" title="0">return response.Choices[0].Message.Content, nil</span>
}

// GeminiProvider implements AIProvider for Google Gemini (Gemini 2.5 Flash, 2.0 Flash, etc.)
type GeminiProvider struct {
        baseURL string
        model   string
        apiKey  string
        client  *http.Client
}

// NewGeminiProvider creates a new Gemini provider
func NewGeminiProvider(config Config) (*GeminiProvider, error) <span class="cov0" title="0">{
        if config.APIKey == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Gemini API key is required (set GOKANON_AI_API_KEY environment variable)")
        }</span>

        <span class="cov0" title="0">return &amp;GeminiProvider{
                baseURL: config.BaseURL,
                model:   config.Model,
                apiKey:  config.APIKey,
                client: &amp;http.Client{
                        Timeout: 60 * time.Second,
                },
        }, nil</span>
}

// Analyze sends a prompt to Gemini and returns the response
func (p *GeminiProvider) Analyze(prompt string) (string, error) <span class="cov0" title="0">{
        requestBody := map[string]interface{}{
                "contents": []map[string]interface{}{
                        {
                                "parts": []map[string]string{
                                        {
                                                "text": fmt.Sprintf("You are an expert Go performance analyst. Provide concise, actionable insights about benchmark results.\n\n%s", prompt),
                                        },
                                },
                        },
                },
                "generationConfig": map[string]interface{}{
                        "temperature":     0.7,
                        "maxOutputTokens": 2000,
                },
        }

        jsonData, err := json.Marshal(requestBody)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to marshal request: %w", err)
        }</span>

        // Gemini uses model in the URL path
        <span class="cov0" title="0">url := fmt.Sprintf("%s/v1beta/models/%s:generateContent?key=%s", p.baseURL, p.model, p.apiKey)
        req, err := http.NewRequest("POST", url, bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")

        resp, err := p.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to send request to Gemini: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return "", fmt.Errorf("Gemini API error (status %d): %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">var response struct {
                Candidates []struct {
                        Content struct {
                                Parts []struct {
                                        Text string `json:"text"`
                                } `json:"parts"`
                        } `json:"content"`
                } `json:"candidates"`
        }

        if err := json.NewDecoder(resp.Body).Decode(&amp;response); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to decode Gemini response: %w", err)
        }</span>

        <span class="cov0" title="0">if len(response.Candidates) == 0 || len(response.Candidates[0].Content.Parts) == 0 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no response from Gemini")
        }</span>

        // Concatenate all text parts
        <span class="cov0" title="0">var result string
        for _, part := range response.Candidates[0].Content.Parts </span><span class="cov0" title="0">{
                result += part.Text
        }</span>

        <span class="cov0" title="0">if result == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no text content in Gemini response")
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package cli

import (
        "fmt"
        "os"

        "github.com/alenon/gokanon/internal/cli/commands"
        "github.com/alenon/gokanon/internal/ui"
)

const (
        usageText = `gokanon - A CLI tool for running and comparing Go benchmarks

Usage:
  gokanon &lt;command&gt; [options]

Commands:
  run          Run benchmarks and save results
  list         List all saved benchmark results
  compare      Compare two benchmark results
  export       Export comparison results to various formats
  stats        Show statistical analysis of multiple runs
  trend        Analyze performance trends over time
  check        Check performance against thresholds (for CI/CD)
  flamegraph   View CPU/memory flame graphs for a run
  serve        Start interactive web dashboard
  delete       Delete a benchmark result
  baseline     Manage baseline benchmarks (save, load, list, show, delete)
  doctor       Run diagnostics to check your setup
  interactive  Start interactive mode with auto-completion
  completion   Install shell completion scripts
  help         Show this help message

Examples:
  gokanon run                            # Run all benchmarks in current package
  gokanon run -bench=. -pkg=./...        # Run all benchmarks in all packages
  gokanon run -bench=BenchmarkFoo        # Run specific benchmark
  gokanon run -profile=cpu,mem           # Run with CPU and memory profiling
  gokanon list                           # List all saved results
  gokanon compare run-123 run-456        # Compare two specific runs
  gokanon compare --latest               # Compare last two runs
  gokanon compare --baseline=v1.0        # Compare latest run with baseline
  gokanon export --latest -format=html   # Export comparison to HTML
  gokanon stats -last=5                  # Show stats for last 5 runs
  gokanon trend -last=10                 # Show performance trends
  gokanon check --latest -threshold=10   # Check if degradation &gt; 10%
  gokanon flamegraph run-123             # View flame graphs in browser
  gokanon serve                          # Start interactive web dashboard
  gokanon serve -port=9000               # Start dashboard on custom port
  gokanon delete run-123                 # Delete a specific run
  gokanon baseline save -name=v1.0       # Save latest run as baseline
  gokanon baseline save -name=v1.0 -run=run-123  # Save specific run as baseline
  gokanon baseline list                  # List all saved baselines
  gokanon baseline show -name=v1.0       # Show baseline details
  gokanon baseline delete -name=v1.0     # Delete a baseline
  gokanon doctor                         # Check your setup
  gokanon interactive                    # Start interactive mode
  gokanon completion bash                # Install bash completion

For more information about a command, use:
  gokanon &lt;command&gt; -h
`
)

// Execute is the main entry point for the CLI
func Execute() error <span class="cov0" title="0">{
        if len(os.Args) &lt; 2 </span><span class="cov0" title="0">{
                fmt.Print(usageText)
                return nil
        }</span>

        <span class="cov0" title="0">command := os.Args[1]

        switch command </span>{
        case "run":<span class="cov0" title="0">
                return commands.Run()</span>
        case "list":<span class="cov0" title="0">
                return commands.List()</span>
        case "compare":<span class="cov0" title="0">
                return commands.Compare()</span>
        case "export":<span class="cov0" title="0">
                return commands.Export()</span>
        case "stats":<span class="cov0" title="0">
                return commands.Stats()</span>
        case "trend":<span class="cov0" title="0">
                return commands.Trend()</span>
        case "check":<span class="cov0" title="0">
                return commands.Check()</span>
        case "flamegraph":<span class="cov0" title="0">
                return commands.Flamegraph()</span>
        case "serve":<span class="cov0" title="0">
                return commands.Serve()</span>
        case "delete":<span class="cov0" title="0">
                return commands.Delete()</span>
        case "baseline":<span class="cov0" title="0">
                return commands.Baseline()</span>
        case "doctor":<span class="cov0" title="0">
                return commands.Doctor()</span>
        case "interactive", "i":<span class="cov0" title="0">
                return commands.Interactive()</span>
        case "completion":<span class="cov0" title="0">
                return commands.Completion()</span>
        case "help", "-h", "--help":<span class="cov0" title="0">
                fmt.Print(usageText)
                return nil</span>
        default:<span class="cov0" title="0">
                return ui.NewError(
                        fmt.Sprintf("Unknown command: %s", command),
                        nil,
                        "Run 'gokanon help' to see available commands",
                        "Use 'gokanon &lt;command&gt; -h' for command-specific help",
                        "Try 'gokanon interactive' for an interactive experience",
                )</span>
        }
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package commands

import (
        "flag"
        "fmt"
        "os"
        "text/tabwriter"
        "time"

        "github.com/alenon/gokanon/internal/storage"
        "github.com/alenon/gokanon/internal/ui"
)

// Baseline handles the 'baseline' subcommand
func Baseline() error <span class="cov10" title="4">{
        if len(os.Args) &lt; 3 </span><span class="cov0" title="0">{
                fmt.Println("Baseline management commands:")
                fmt.Println()
                fmt.Println("Usage:")
                fmt.Println("  gokanon baseline &lt;subcommand&gt; [options]")
                fmt.Println()
                fmt.Println("Subcommands:")
                fmt.Println("  save     Save a benchmark run as a baseline")
                fmt.Println("  list     List all saved baselines")
                fmt.Println("  show     Show details of a specific baseline")
                fmt.Println("  delete   Delete a baseline")
                fmt.Println()
                fmt.Println("Examples:")
                fmt.Println("  gokanon baseline save -name=v1.0")
                fmt.Println("  gokanon baseline save -name=main -run=run-123 -desc='Main branch baseline'")
                fmt.Println("  gokanon baseline list")
                fmt.Println("  gokanon baseline show -name=v1.0")
                fmt.Println("  gokanon baseline delete -name=v1.0")
                fmt.Println()
                return nil
        }</span>

        <span class="cov10" title="4">subcommand := os.Args[2]

        switch subcommand </span>{
        case "save":<span class="cov1" title="1">
                return baselineSave()</span>
        case "list":<span class="cov1" title="1">
                return baselineList()</span>
        case "show":<span class="cov0" title="0">
                return baselineShow()</span>
        case "delete":<span class="cov1" title="1">
                return baselineDelete()</span>
        default:<span class="cov1" title="1">
                return ui.NewError(
                        fmt.Sprintf("Unknown baseline subcommand: %s", subcommand),
                        nil,
                        "Valid subcommands: save, list, show, delete",
                        "Run 'gokanon baseline' to see usage",
                )</span>
        }
}

// baselineSave saves a benchmark run as a baseline
func baselineSave() error <span class="cov1" title="1">{
        saveFlags := flag.NewFlagSet("baseline-save", flag.ExitOnError)
        name := saveFlags.String("name", "", "Baseline name (required)")
        runID := saveFlags.String("run", "", "Run ID to save as baseline (default: latest run)")
        description := saveFlags.String("desc", "", "Baseline description")
        storageDir := saveFlags.String("storage", ".gokanon", "Storage directory for results")
        saveFlags.Parse(os.Args[3:])

        if *name == "" </span><span class="cov1" title="1">{
                return ui.NewError(
                        "Baseline name is required",
                        nil,
                        "Use -name flag to specify baseline name",
                        "Example: gokanon baseline save -name=v1.0",
                )
        }</span>

        <span class="cov0" title="0">store := storage.NewStorage(*storageDir)

        // Determine which run to use
        var targetRunID string
        if *runID != "" </span><span class="cov0" title="0">{
                targetRunID = *runID
        }</span> else<span class="cov0" title="0"> {
                // Use latest run
                run, err := store.GetLatest()
                if err != nil </span><span class="cov0" title="0">{
                        return ui.NewError(
                                "Failed to get latest run",
                                err,
                                "No benchmark runs found",
                                "Run 'gokanon run' first to create a benchmark run",
                        )
                }</span>
                <span class="cov0" title="0">targetRunID = run.ID</span>
        }

        // Save baseline
        <span class="cov0" title="0">ui.PrintInfo("Saving baseline '%s' from run %s...", *name, targetRunID)
        baseline, err := store.SaveBaseline(*name, targetRunID, *description, nil)
        if err != nil </span><span class="cov0" title="0">{
                return ui.NewError(
                        "Failed to save baseline",
                        err,
                        "Check that the run ID exists and storage directory is writable",
                        "Try: gokanon list",
                )
        }</span>

        <span class="cov0" title="0">fmt.Println()
        ui.PrintSuccess("Baseline saved successfully!")
        fmt.Printf("Name:        %s\n", ui.Bold(baseline.Name))
        fmt.Printf("Run ID:      %s\n", baseline.RunID)
        fmt.Printf("Created:     %s\n", baseline.CreatedAt.Format(time.RFC3339))
        if baseline.Description != "" </span><span class="cov0" title="0">{
                fmt.Printf("Description: %s\n", baseline.Description)
        }</span>
        <span class="cov0" title="0">fmt.Printf("Benchmarks:  %d\n", len(baseline.Run.Results))
        fmt.Println()
        fmt.Printf("Baseline saved to: %s/baselines/%s.json\n", *storageDir, baseline.Name)
        return nil</span>
}

// baselineList lists all saved baselines
func baselineList() error <span class="cov1" title="1">{
        listFlags := flag.NewFlagSet("baseline-list", flag.ExitOnError)
        storageDir := listFlags.String("storage", ".gokanon", "Storage directory for results")
        listFlags.Parse(os.Args[3:])

        store := storage.NewStorage(*storageDir)
        baselines, err := store.ListBaselines()
        if err != nil </span><span class="cov0" title="0">{
                return ui.NewError(
                        "Failed to list baselines",
                        err,
                        "Check storage directory permissions",
                )
        }</span>

        <span class="cov1" title="1">if len(baselines) == 0 </span><span class="cov1" title="1">{
                fmt.Println("No baselines found.")
                fmt.Println()
                fmt.Println("Create a baseline with: gokanon baseline save -name=&lt;name&gt;")
                return nil
        }</span>

        <span class="cov0" title="0">ui.PrintHeader("Saved Baselines")
        fmt.Println()

        w := tabwriter.NewWriter(os.Stdout, 0, 0, 2, ' ', 0)
        fmt.Fprintln(w, "Name\tCreated\tBenchmarks\tDescription")
        fmt.Fprintln(w, "----\t-------\t----------\t-----------")

        for _, baseline := range baselines </span><span class="cov0" title="0">{
                desc := baseline.Description
                if desc == "" </span><span class="cov0" title="0">{
                        desc = "-"
                }</span>
                <span class="cov0" title="0">if len(desc) &gt; 50 </span><span class="cov0" title="0">{
                        desc = desc[:47] + "..."
                }</span>
                <span class="cov0" title="0">fmt.Fprintf(w, "%s\t%s\t%d\t%s\n",
                        baseline.Name,
                        baseline.CreatedAt.Format("2006-01-02 15:04"),
                        len(baseline.Run.Results),
                        desc,
                )</span>
        }
        <span class="cov0" title="0">w.Flush()
        fmt.Println()

        return nil</span>
}

// baselineShow shows details of a specific baseline
func baselineShow() error <span class="cov0" title="0">{
        showFlags := flag.NewFlagSet("baseline-show", flag.ExitOnError)
        name := showFlags.String("name", "", "Baseline name (required)")
        storageDir := showFlags.String("storage", ".gokanon", "Storage directory for results")
        showFlags.Parse(os.Args[3:])

        if *name == "" </span><span class="cov0" title="0">{
                return ui.NewError(
                        "Baseline name is required",
                        nil,
                        "Use -name flag to specify baseline name",
                        "Example: gokanon baseline show -name=v1.0",
                )
        }</span>

        <span class="cov0" title="0">store := storage.NewStorage(*storageDir)
        baseline, err := store.LoadBaseline(*name)
        if err != nil </span><span class="cov0" title="0">{
                return ui.NewError(
                        fmt.Sprintf("Failed to load baseline '%s'", *name),
                        err,
                        "Check that the baseline exists",
                        "Try: gokanon baseline list",
                )
        }</span>

        <span class="cov0" title="0">ui.PrintHeader(fmt.Sprintf("Baseline: %s", baseline.Name))
        fmt.Println()

        fmt.Printf("Name:        %s\n", ui.Bold(baseline.Name))
        fmt.Printf("Run ID:      %s\n", baseline.RunID)
        fmt.Printf("Created:     %s\n", baseline.CreatedAt.Format(time.RFC3339))
        if baseline.Description != "" </span><span class="cov0" title="0">{
                fmt.Printf("Description: %s\n", baseline.Description)
        }</span>
        <span class="cov0" title="0">fmt.Println()

        ui.PrintSection(ui.ChartEmoji, "Run Information")
        fmt.Printf("  Timestamp:  %s\n", baseline.Run.Timestamp.Format(time.RFC3339))
        fmt.Printf("  Duration:   %s\n", baseline.Run.Duration.String())
        fmt.Printf("  Go Version: %s\n", baseline.Run.GoVersion)
        fmt.Printf("  Package:    %s\n", baseline.Run.Package)
        fmt.Println()

        w := tabwriter.NewWriter(os.Stdout, 0, 0, 2, ' ', 0)
        fmt.Fprintln(w, "Benchmark\tIterations\tns/op\tB/op\tallocs/op")
        fmt.Fprintln(w, "---------\t----------\t-----\t----\t---------")
        for _, result := range baseline.Run.Results </span><span class="cov0" title="0">{
                fmt.Fprintf(w, "%s\t%d\t%.2f\t%d\t%d\n",
                        result.Name,
                        result.Iterations,
                        result.NsPerOp,
                        result.BytesPerOp,
                        result.AllocsPerOp,
                )
        }</span>
        <span class="cov0" title="0">w.Flush()

        return nil</span>
}

// baselineDelete deletes a baseline
func baselineDelete() error <span class="cov1" title="1">{
        deleteFlags := flag.NewFlagSet("baseline-delete", flag.ExitOnError)
        name := deleteFlags.String("name", "", "Baseline name (required)")
        storageDir := deleteFlags.String("storage", ".gokanon", "Storage directory for results")
        deleteFlags.Parse(os.Args[3:])

        if *name == "" </span><span class="cov1" title="1">{
                return ui.NewError(
                        "Baseline name is required",
                        nil,
                        "Use -name flag to specify baseline name",
                        "Example: gokanon baseline delete -name=v1.0",
                )
        }</span>

        <span class="cov0" title="0">store := storage.NewStorage(*storageDir)

        // Check if baseline exists
        if !store.HasBaseline(*name) </span><span class="cov0" title="0">{
                return ui.NewError(
                        fmt.Sprintf("Baseline '%s' not found", *name),
                        nil,
                        "Check that the baseline exists",
                        "Try: gokanon baseline list",
                )
        }</span>

        // Delete baseline
        <span class="cov0" title="0">if err := store.DeleteBaseline(*name); err != nil </span><span class="cov0" title="0">{
                return ui.NewError(
                        "Failed to delete baseline",
                        err,
                        "Check storage directory permissions",
                )
        }</span>

        <span class="cov0" title="0">ui.PrintSuccess("Baseline '%s' deleted successfully", *name)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package commands

import (
        "flag"
        "fmt"
        "os"

        "github.com/alenon/gokanon/internal/compare"
        "github.com/alenon/gokanon/internal/storage"
        "github.com/alenon/gokanon/internal/threshold"
)

// Check handles the 'check' subcommand for CI/CD
func Check() error <span class="cov8" title="1">{
        checkFlags := flag.NewFlagSet("check", flag.ExitOnError)
        storageDir := checkFlags.String("storage", ".gokanon", "Storage directory for results")
        latest := checkFlags.Bool("latest", false, "Check last two runs")
        thresholdPercent := checkFlags.Float64("threshold", 5.0, "Maximum allowed performance degradation (%)")
        checkFlags.Parse(os.Args[2:])

        store := storage.NewStorage(*storageDir)

        var oldID, newID string

        if *latest </span><span class="cov0" title="0">{
                runs, err := store.List()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to list results: %w", err)
                }</span>
                <span class="cov0" title="0">if len(runs) &lt; 2 </span><span class="cov0" title="0">{
                        return fmt.Errorf("need at least 2 benchmark runs to check")
                }</span>
                <span class="cov0" title="0">newID = runs[0].ID
                oldID = runs[1].ID</span>
        } else<span class="cov8" title="1"> {
                args := checkFlags.Args()
                if len(args) != 2 </span><span class="cov8" title="1">{
                        return fmt.Errorf("usage: gokanon check &lt;old-id&gt; &lt;new-id&gt; OR gokanon check --latest")
                }</span>
                <span class="cov0" title="0">oldID = args[0]
                newID = args[1]</span>
        }

        // Load benchmark runs
        <span class="cov0" title="0">oldRun, err := store.Load(oldID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load old run: %w", err)
        }</span>

        <span class="cov0" title="0">newRun, err := store.Load(newID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load new run: %w", err)
        }</span>

        // Compare
        <span class="cov0" title="0">comparer := compare.NewComparer()
        comparisons := comparer.Compare(oldRun, newRun)

        if len(comparisons) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no matching benchmarks found between the two runs")
        }</span>

        // Check thresholds
        <span class="cov0" title="0">checker := threshold.NewChecker(*thresholdPercent)
        result := checker.Check(comparisons)

        // Display result
        fmt.Printf("Threshold Check (max degradation: %.1f%%)\n", *thresholdPercent)
        fmt.Printf("Comparing: %s vs %s\n\n", oldID, newID)
        fmt.Println(threshold.FormatResult(result))

        // Exit with appropriate code for CI/CD
        if !result.Passed </span><span class="cov0" title="0">{
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package commands

import (
        "flag"
        "fmt"
        "os"

        "github.com/alenon/gokanon/internal/aianalyzer"
        "github.com/alenon/gokanon/internal/compare"
        "github.com/alenon/gokanon/internal/models"
        "github.com/alenon/gokanon/internal/storage"
        "github.com/alenon/gokanon/internal/ui"
)

// Compare handles the 'compare' subcommand
func Compare() error <span class="cov10" title="2">{
        compareFlags := flag.NewFlagSet("compare", flag.ExitOnError)
        storageDir := compareFlags.String("storage", ".gokanon", "Storage directory for results")
        latest := compareFlags.Bool("latest", false, "Compare the last two runs")
        baseline := compareFlags.String("baseline", "", "Compare latest run against a baseline")
        compareFlags.Parse(os.Args[2:])

        store := storage.NewStorage(*storageDir)

        var oldID, newID string
        var oldRun, newRun *models.BenchmarkRun

        if *baseline != "" </span><span class="cov0" title="0">{
                // Compare latest run against baseline
                baselineData, err := store.LoadBaseline(*baseline)
                if err != nil </span><span class="cov0" title="0">{
                        return ui.NewError(
                                fmt.Sprintf("Failed to load baseline '%s'", *baseline),
                                err,
                                "Check that the baseline exists",
                                "Try: gokanon baseline list",
                        )
                }</span>

                <span class="cov0" title="0">latestRun, err := store.GetLatest()
                if err != nil </span><span class="cov0" title="0">{
                        return ui.NewError(
                                "Failed to get latest run",
                                err,
                                "No benchmark runs found",
                                "Run 'gokanon run' first",
                        )
                }</span>

                <span class="cov0" title="0">oldRun = baselineData.Run
                newRun = latestRun
                oldID = baselineData.Name + " (baseline)"
                newID = latestRun.ID</span>
        } else<span class="cov10" title="2"> if *latest </span><span class="cov0" title="0">{
                // Get the two most recent runs
                runs, err := store.List()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to list results: %w", err)
                }</span>
                <span class="cov0" title="0">if len(runs) &lt; 2 </span><span class="cov0" title="0">{
                        return fmt.Errorf("need at least 2 benchmark runs to compare")
                }</span>
                <span class="cov0" title="0">newID = runs[0].ID
                oldID = runs[1].ID</span>
        } else<span class="cov10" title="2"> {
                // Get IDs from arguments
                args := compareFlags.Args()
                if len(args) != 2 </span><span class="cov10" title="2">{
                        return fmt.Errorf("usage: gokanon compare &lt;old-id&gt; &lt;new-id&gt; OR gokanon compare --latest OR gokanon compare --baseline=&lt;name&gt;")
                }</span>
                <span class="cov0" title="0">oldID = args[0]
                newID = args[1]</span>
        }

        // Load benchmark runs if not already loaded
        <span class="cov0" title="0">if oldRun == nil </span><span class="cov0" title="0">{
                var err error
                oldRun, err = store.Load(oldID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to load old run: %w", err)
                }</span>
        }

        <span class="cov0" title="0">if newRun == nil </span><span class="cov0" title="0">{
                var err error
                newRun, err = store.Load(newID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to load new run: %w", err)
                }</span>
        }

        // Compare
        <span class="cov0" title="0">comparer := compare.NewComparer()
        comparisons := comparer.Compare(oldRun, newRun)

        if len(comparisons) == 0 </span><span class="cov0" title="0">{
                fmt.Println("No matching benchmarks found between the two runs.")
                return nil
        }</span>

        // Display comparison
        <span class="cov0" title="0">fmt.Printf("Comparing: %s (%s) vs %s (%s)\n\n",
                oldID, oldRun.Timestamp.Format("2006-01-02 15:04:05"),
                newID, newRun.Timestamp.Format("2006-01-02 15:04:05"),
        )

        for _, comp := range comparisons </span><span class="cov0" title="0">{
                fmt.Println(compare.FormatComparison(comp))
        }</span>

        <span class="cov0" title="0">fmt.Printf("\n%s\n", compare.Summary(comparisons))

        // Add AI analysis if enabled
        aiAnalyzer, err := aianalyzer.NewFromEnv()
        if err == nil </span><span class="cov0" title="0">{
                analysis, err := aiAnalyzer.AnalyzeComparison(oldRun, newRun, comparisons)
                if err == nil &amp;&amp; analysis != "" </span><span class="cov0" title="0">{
                        fmt.Printf("\n--- AI Analysis ---\n%s\n", analysis)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package commands

import (
        "fmt"
        "os"

        "github.com/alenon/gokanon/internal/ui"
)

// Completion installs shell completion scripts
func Completion() error <span class="cov10" title="2">{
        if len(os.Args) &lt; 3 </span><span class="cov1" title="1">{
                fmt.Println(ui.Bold("gokanon completion - Install shell completion"))
                fmt.Println()
                fmt.Println("Usage:")
                fmt.Println("  gokanon completion &lt;shell&gt;")
                fmt.Println()
                fmt.Println("Available shells:")
                fmt.Println("  bash    Bash completion")
                fmt.Println("  zsh     Zsh completion")
                fmt.Println("  fish    Fish completion")
                fmt.Println()
                fmt.Println("Installation instructions:")
                fmt.Println()
                fmt.Println(ui.Bold("Bash:"))
                fmt.Println("  gokanon completion bash &gt; /etc/bash_completion.d/gokanon")
                fmt.Println("  # or for user-only installation:")
                fmt.Println("  gokanon completion bash &gt; ~/.local/share/bash-completion/completions/gokanon")
                fmt.Println()
                fmt.Println(ui.Bold("Zsh:"))
                fmt.Println("  gokanon completion zsh &gt; /usr/local/share/zsh/site-functions/_gokanon")
                fmt.Println("  # or add to your .zshrc:")
                fmt.Println("  source &lt;(gokanon completion zsh)")
                fmt.Println()
                fmt.Println(ui.Bold("Fish:"))
                fmt.Println("  gokanon completion fish &gt; ~/.config/fish/completions/gokanon.fish")
                fmt.Println()
                return nil
        }</span>

        <span class="cov1" title="1">shell := os.Args[2]

        // Read the completion script from embedded file
        scriptPath := ""
        switch shell </span>{
        case "bash":<span class="cov0" title="0">
                scriptPath = "scripts/completions/gokanon.bash"</span>
        case "zsh":<span class="cov0" title="0">
                scriptPath = "scripts/completions/gokanon.zsh"</span>
        case "fish":<span class="cov0" title="0">
                scriptPath = "scripts/completions/gokanon.fish"</span>
        default:<span class="cov1" title="1">
                return ui.NewError(
                        fmt.Sprintf("Unsupported shell: %s", shell),
                        nil,
                        "Supported shells: bash, zsh, fish",
                        "Example: gokanon completion bash",
                )</span>
        }

        // Read the completion script from the file
        <span class="cov0" title="0">content, err := os.ReadFile(scriptPath)
        if err != nil </span><span class="cov0" title="0">{
                return ui.NewError(
                        "Failed to read completion script",
                        err,
                        "Ensure gokanon is properly installed",
                        "You may need to reinstall gokanon",
                )
        }</span>

        <span class="cov0" title="0">fmt.Print(string(content))
        return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package commands

import (
        "flag"
        "fmt"
        "os"

        "github.com/alenon/gokanon/internal/storage"
)

// Delete handles the 'delete' subcommand
func Delete() error <span class="cov10" title="3">{
        deleteFlags := flag.NewFlagSet("delete", flag.ExitOnError)
        storageDir := deleteFlags.String("storage", ".gokanon", "Storage directory for results")
        deleteFlags.Parse(os.Args[2:])

        args := deleteFlags.Args()
        if len(args) != 1 </span><span class="cov1" title="1">{
                return fmt.Errorf("usage: gokanon delete &lt;id&gt;")
        }</span>

        <span class="cov6" title="2">id := args[0]
        store := storage.NewStorage(*storageDir)

        if err := store.Delete(id); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to delete run: %w", err)
        }</span>

        <span class="cov1" title="1">fmt.Printf("Deleted benchmark run: %s\n", id)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package commands

import (
        "fmt"

        "github.com/alenon/gokanon/internal/doctor"
)

// Doctor runs diagnostics to check the setup
func Doctor() error <span class="cov1" title="1">{
        results := doctor.RunDiagnostics()
        doctor.PrintResults(results)

        // Return error if any critical checks failed
        for _, result := range results </span><span class="cov10" title="7">{
                if !result.Passed &amp;&amp; (result.Name == "Go Installation" || result.Name == "Go Test Command") </span><span class="cov0" title="0">{
                        return fmt.Errorf("critical check failed: %s", result.Name)
                }</span>
        }

        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package commands

import (
        "flag"
        "fmt"
        "os"

        "github.com/alenon/gokanon/internal/compare"
        "github.com/alenon/gokanon/internal/export"
        "github.com/alenon/gokanon/internal/storage"
)

// Export handles the 'export' subcommand
func Export() error <span class="cov10" title="3">{
        exportFlags := flag.NewFlagSet("export", flag.ExitOnError)
        storageDir := exportFlags.String("storage", ".gokanon", "Storage directory for results")
        latest := exportFlags.Bool("latest", false, "Export comparison of last two runs")
        format := exportFlags.String("format", "html", "Export format: html, csv, markdown")
        output := exportFlags.String("output", "", "Output file (default: comparison.&lt;format&gt;)")
        exportFlags.Parse(os.Args[2:])

        store := storage.NewStorage(*storageDir)

        var oldID, newID string

        if *latest </span><span class="cov0" title="0">{
                runs, err := store.List()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to list results: %w", err)
                }</span>
                <span class="cov0" title="0">if len(runs) &lt; 2 </span><span class="cov0" title="0">{
                        return fmt.Errorf("need at least 2 benchmark runs to export")
                }</span>
                <span class="cov0" title="0">newID = runs[0].ID
                oldID = runs[1].ID</span>
        } else<span class="cov10" title="3"> {
                args := exportFlags.Args()
                if len(args) != 2 </span><span class="cov10" title="3">{
                        return fmt.Errorf("usage: gokanon export &lt;old-id&gt; &lt;new-id&gt; OR gokanon export --latest")
                }</span>
                <span class="cov0" title="0">oldID = args[0]
                newID = args[1]</span>
        }

        // Load benchmark runs
        <span class="cov0" title="0">oldRun, err := store.Load(oldID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load old run: %w", err)
        }</span>

        <span class="cov0" title="0">newRun, err := store.Load(newID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load new run: %w", err)
        }</span>

        // Compare
        <span class="cov0" title="0">comparer := compare.NewComparer()
        comparisons := comparer.Compare(oldRun, newRun)

        if len(comparisons) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no matching benchmarks found between the two runs")
        }</span>

        // Determine output filename
        <span class="cov0" title="0">outputFile := *output
        if outputFile == "" </span><span class="cov0" title="0">{
                outputFile = fmt.Sprintf("comparison.%s", *format)
        }</span>

        // Export
        <span class="cov0" title="0">exporter := export.NewExporter()
        switch *format </span>{
        case "html":<span class="cov0" title="0">
                err = exporter.ToHTML(
                        comparisons,
                        oldID, newID,
                        oldRun.Timestamp.Format("2006-01-02 15:04:05"),
                        newRun.Timestamp.Format("2006-01-02 15:04:05"),
                        outputFile,
                )</span>
        case "csv":<span class="cov0" title="0">
                err = exporter.ToCSV(comparisons, outputFile)</span>
        case "markdown", "md":<span class="cov0" title="0">
                err = exporter.ToMarkdown(comparisons, oldID, newID, outputFile)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported format: %s (supported: html, csv, markdown)", *format)</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to export: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Comparison exported to: %s\n", outputFile)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package commands

import (
        "flag"
        "fmt"
        "os"

        "github.com/alenon/gokanon/internal/storage"
        "github.com/alenon/gokanon/internal/webserver"
)

// Flamegraph handles the 'flamegraph' subcommand
func Flamegraph() error <span class="cov8" title="1">{
        flamegraphFlags := flag.NewFlagSet("flamegraph", flag.ExitOnError)
        storageDir := flamegraphFlags.String("storage", ".gokanon", "Storage directory for results")
        port := flamegraphFlags.String("port", "8080", "Port for web server")
        latest := flamegraphFlags.Bool("latest", false, "View profiles for latest run")
        flamegraphFlags.Parse(os.Args[2:])

        store := storage.NewStorage(*storageDir)

        var runID string

        if *latest </span><span class="cov0" title="0">{
                // Get the most recent run
                latestRun, err := store.GetLatest()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get latest run: %w", err)
                }</span>
                <span class="cov0" title="0">runID = latestRun.ID</span>
        } else<span class="cov8" title="1"> {
                // Get run ID from arguments
                args := flamegraphFlags.Args()
                if len(args) != 1 </span><span class="cov8" title="1">{
                        return fmt.Errorf("usage: gokanon flamegraph &lt;run-id&gt; OR gokanon flamegraph --latest")
                }</span>
                <span class="cov0" title="0">runID = args[0]</span>
        }

        // Load the run to verify it has profiles
        <span class="cov0" title="0">run, err := store.Load(runID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load run: %w", err)
        }</span>

        <span class="cov0" title="0">if run.CPUProfile == "" &amp;&amp; run.MemoryProfile == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("no profiles found for run %s\n\nRun benchmarks with profiling enabled:\n  gokanon run --profile=cpu,mem", runID)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Starting flame graph viewer for run: %s\n", runID)
        if run.CPUProfile != "" </span><span class="cov0" title="0">{
                fmt.Println("   CPU profile available")
        }</span>
        <span class="cov0" title="0">if run.MemoryProfile != "" </span><span class="cov0" title="0">{
                fmt.Println("   Memory profile available")
        }</span>
        <span class="cov0" title="0">fmt.Println()

        // Start web server
        server := webserver.NewServer(store, *port)
        return server.Start(runID)</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package commands

import (
        "os"

        "github.com/alenon/gokanon/internal/interactive"
        "github.com/alenon/gokanon/internal/ui"
)

// Interactive starts the interactive mode
func Interactive() error <span class="cov0" title="0">{
        session, err := interactive.New()
        if err != nil </span><span class="cov0" title="0">{
                return ui.NewError(
                        "Failed to start interactive mode",
                        err,
                        "Ensure your terminal supports interactive input",
                        "Try running individual commands instead: 'gokanon help'",
                )
        }</span>

        // Register all command handlers
        <span class="cov0" title="0">session.RegisterCommand("run", func(args []string) error </span><span class="cov0" title="0">{
                os.Args = append([]string{"gokanon", "run"}, args...)
                return Run()
        }</span>)

        <span class="cov0" title="0">session.RegisterCommand("list", func(args []string) error </span><span class="cov0" title="0">{
                os.Args = append([]string{"gokanon", "list"}, args...)
                return List()
        }</span>)

        <span class="cov0" title="0">session.RegisterCommand("compare", func(args []string) error </span><span class="cov0" title="0">{
                os.Args = append([]string{"gokanon", "compare"}, args...)
                return Compare()
        }</span>)

        <span class="cov0" title="0">session.RegisterCommand("export", func(args []string) error </span><span class="cov0" title="0">{
                os.Args = append([]string{"gokanon", "export"}, args...)
                return Export()
        }</span>)

        <span class="cov0" title="0">session.RegisterCommand("stats", func(args []string) error </span><span class="cov0" title="0">{
                os.Args = append([]string{"gokanon", "stats"}, args...)
                return Stats()
        }</span>)

        <span class="cov0" title="0">session.RegisterCommand("trend", func(args []string) error </span><span class="cov0" title="0">{
                os.Args = append([]string{"gokanon", "trend"}, args...)
                return Trend()
        }</span>)

        <span class="cov0" title="0">session.RegisterCommand("check", func(args []string) error </span><span class="cov0" title="0">{
                os.Args = append([]string{"gokanon", "check"}, args...)
                return Check()
        }</span>)

        <span class="cov0" title="0">session.RegisterCommand("flamegraph", func(args []string) error </span><span class="cov0" title="0">{
                os.Args = append([]string{"gokanon", "flamegraph"}, args...)
                return Flamegraph()
        }</span>)

        <span class="cov0" title="0">session.RegisterCommand("serve", func(args []string) error </span><span class="cov0" title="0">{
                os.Args = append([]string{"gokanon", "serve"}, args...)
                return Serve()
        }</span>)

        <span class="cov0" title="0">session.RegisterCommand("delete", func(args []string) error </span><span class="cov0" title="0">{
                os.Args = append([]string{"gokanon", "delete"}, args...)
                return Delete()
        }</span>)

        <span class="cov0" title="0">session.RegisterCommand("doctor", func(args []string) error </span><span class="cov0" title="0">{
                return Doctor()
        }</span>)

        <span class="cov0" title="0">return session.Run()</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package commands

import (
        "flag"
        "fmt"
        "os"
        "text/tabwriter"

        "github.com/alenon/gokanon/internal/storage"
)

// List handles the 'list' subcommand
func List() error <span class="cov10" title="4">{
        listFlags := flag.NewFlagSet("list", flag.ExitOnError)
        storageDir := listFlags.String("storage", ".gokanon", "Storage directory for results")
        listFlags.Parse(os.Args[2:])

        store := storage.NewStorage(*storageDir)
        runs, err := store.List()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to list results: %w", err)
        }</span>

        <span class="cov10" title="4">if len(runs) == 0 </span><span class="cov5" title="2">{
                fmt.Println("No benchmark results found.")
                return nil
        }</span>

        <span class="cov5" title="2">w := tabwriter.NewWriter(os.Stdout, 0, 0, 2, ' ', 0)
        fmt.Fprintln(w, "ID\tTimestamp\tBenchmarks\tDuration\tPackage")
        fmt.Fprintln(w, "--\t---------\t----------\t--------\t-------")

        for _, run := range runs </span><span class="cov10" title="4">{
                fmt.Fprintf(w, "%s\t%s\t%d\t%s\t%s\n",
                        run.ID,
                        run.Timestamp.Format("2006-01-02 15:04:05"),
                        len(run.Results),
                        run.Duration,
                        run.Package,
                )
        }</span>
        <span class="cov5" title="2">w.Flush()

        return nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package commands

import (
        "flag"
        "fmt"
        "os"
        "strings"
        "text/tabwriter"
        "time"

        "github.com/alenon/gokanon/internal/models"
        "github.com/alenon/gokanon/internal/runner"
        "github.com/alenon/gokanon/internal/storage"
        "github.com/alenon/gokanon/internal/ui"
)

// Run handles the 'run' subcommand
func Run() error <span class="cov0" title="0">{
        runFlags := flag.NewFlagSet("run", flag.ExitOnError)
        benchFilter := runFlags.String("bench", ".", "Benchmark filter (passed to -bench)")
        packagePath := runFlags.String("pkg", "", "Package path (default: current directory)")
        storageDir := runFlags.String("storage", ".gokanon", "Storage directory for results")
        profileFlag := runFlags.String("profile", "", "Enable profiling: cpu, mem, or cpu,mem")
        runFlags.Parse(os.Args[2:])

        ui.PrintHeader("Running Benchmarks")
        fmt.Println()

        // Parse profile options
        var profileOpts *runner.ProfileOptions
        if *profileFlag != "" </span><span class="cov0" title="0">{
                store := storage.NewStorage(*storageDir)
                profileOpts = &amp;runner.ProfileOptions{
                        Storage: store,
                }

                profiles := strings.Split(*profileFlag, ",")
                for _, p := range profiles </span><span class="cov0" title="0">{
                        p = strings.TrimSpace(strings.ToLower(p))
                        switch p </span>{
                        case "cpu":<span class="cov0" title="0">
                                profileOpts.EnableCPU = true</span>
                        case "mem", "memory":<span class="cov0" title="0">
                                profileOpts.EnableMemory = true</span>
                        default:<span class="cov0" title="0">
                                return ui.NewError(
                                        fmt.Sprintf("Unknown profile type: %s", p),
                                        nil,
                                        "Valid profile types: cpu, mem",
                                        "Example: -profile=cpu,mem",
                                )</span>
                        }
                }

                <span class="cov0" title="0">if profileOpts.EnableCPU || profileOpts.EnableMemory </span><span class="cov0" title="0">{
                        var enabled []string
                        if profileOpts.EnableCPU </span><span class="cov0" title="0">{
                                enabled = append(enabled, "CPU")
                        }</span>
                        <span class="cov0" title="0">if profileOpts.EnableMemory </span><span class="cov0" title="0">{
                                enabled = append(enabled, "Memory")
                        }</span>
                        <span class="cov0" title="0">ui.PrintInfo("Profiling enabled: %s", strings.Join(enabled, ", "))</span>
                }
        }

        // Run benchmarks
        <span class="cov0" title="0">spinner := ui.NewSpinner("Executing benchmarks")
        spinner.Start()

        r := runner.NewRunner(*packagePath, *benchFilter)
        if profileOpts != nil </span><span class="cov0" title="0">{
                r = r.WithProfiling(profileOpts)
        }</span>

        <span class="cov0" title="0">run, err := r.Run()
        spinner.Stop()

        if err != nil </span><span class="cov0" title="0">{
                return ui.ErrBenchmarkFailed(err)
        }</span>

        // Save results
        <span class="cov0" title="0">ui.PrintInfo("Saving results...")
        store := storage.NewStorage(*storageDir)
        if err := store.Save(run); err != nil </span><span class="cov0" title="0">{
                return ui.NewError(
                        "Failed to save results",
                        err,
                        "Check file permissions on storage directory",
                        "Ensure you have write access to: "+*storageDir,
                )
        }</span>

        // Display results
        <span class="cov0" title="0">fmt.Println()
        ui.PrintSuccess("Benchmarks completed successfully!")
        fmt.Printf("Results saved with ID: %s\n\n", ui.Bold(run.ID))

        ui.PrintSection(ui.ChartEmoji, "Run Information")
        fmt.Printf("  Timestamp:  %s\n", ui.Dim(run.Timestamp.Format(time.RFC3339)))
        fmt.Printf("  Duration:   %s\n", ui.Info(run.Duration.String()))
        fmt.Printf("  Go Version: %s\n", ui.Info(run.GoVersion))

        // Display profile info if available
        if run.CPUProfile != "" || run.MemoryProfile != "" </span><span class="cov0" title="0">{
                fmt.Printf("\nProfiles:\n")
                if run.CPUProfile != "" </span><span class="cov0" title="0">{
                        fmt.Printf("  CPU: %s\n", run.CPUProfile)
                }</span>
                <span class="cov0" title="0">if run.MemoryProfile != "" </span><span class="cov0" title="0">{
                        fmt.Printf("  Memory: %s\n", run.MemoryProfile)
                }</span>
        }
        <span class="cov0" title="0">fmt.Println()

        w := tabwriter.NewWriter(os.Stdout, 0, 0, 2, ' ', 0)
        fmt.Fprintln(w, "Benchmark\tIterations\tns/op\tB/op\tallocs/op")
        fmt.Fprintln(w, "---------\t----------\t-----\t----\t---------")
        for _, result := range run.Results </span><span class="cov0" title="0">{
                fmt.Fprintf(w, "%s\t%d\t%.2f\t%d\t%d\n",
                        result.Name,
                        result.Iterations,
                        result.NsPerOp,
                        result.BytesPerOp,
                        result.AllocsPerOp,
                )
        }</span>
        <span class="cov0" title="0">w.Flush()

        // Display profile summary if available
        if run.ProfileSummary != nil </span><span class="cov0" title="0">{
                displayProfileSummary(run.ProfileSummary)
        }</span>

        <span class="cov0" title="0">fmt.Printf("\nResults saved to: %s\n", *storageDir)

        // Hint about viewing flame graphs
        if run.CPUProfile != "" || run.MemoryProfile != "" </span><span class="cov0" title="0">{
                fmt.Printf("\nView flame graphs: gokanon flamegraph %s\n", run.ID)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// displayProfileSummary displays profile analysis summary
func displayProfileSummary(summary *models.ProfileSummary) <span class="cov0" title="0">{
        fmt.Println("\n" + strings.Repeat("=", 80))
        fmt.Println("PROFILE ANALYSIS")
        fmt.Println(strings.Repeat("=", 80))

        // CPU Profile Summary
        if len(summary.CPUTopFunctions) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("\n CPU Hot Functions (Total samples: %d)\n", summary.TotalCPUSamples)
                fmt.Println(strings.Repeat("-", 80))

                w := tabwriter.NewWriter(os.Stdout, 0, 0, 2, ' ', 0)
                fmt.Fprintln(w, "Function\tFlat%\tCum%")
                for _, fn := range summary.CPUTopFunctions </span><span class="cov0" title="0">{
                        if len(fn.Name) &gt; 50 </span><span class="cov0" title="0">{
                                fn.Name = fn.Name[:47] + "..."
                        }</span>
                        <span class="cov0" title="0">fmt.Fprintf(w, "%s\t%.1f%%\t%.1f%%\n",
                                fn.Name,
                                fn.FlatPercent,
                                fn.CumPercent,
                        )</span>
                }
                <span class="cov0" title="0">w.Flush()</span>
        }

        // Memory Profile Summary
        <span class="cov0" title="0">if len(summary.MemoryTopFunctions) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("\n Memory Hot Functions (Total: %s)\n", formatBytes(summary.TotalMemoryBytes))
                fmt.Println(strings.Repeat("-", 80))

                w := tabwriter.NewWriter(os.Stdout, 0, 0, 2, ' ', 0)
                fmt.Fprintln(w, "Function\tFlat%\tBytes")
                for _, fn := range summary.MemoryTopFunctions </span><span class="cov0" title="0">{
                        if len(fn.Name) &gt; 50 </span><span class="cov0" title="0">{
                                fn.Name = fn.Name[:47] + "..."
                        }</span>
                        <span class="cov0" title="0">fmt.Fprintf(w, "%s\t%.1f%%\t%s\n",
                                fn.Name,
                                fn.FlatPercent,
                                formatBytes(fn.FlatValue),
                        )</span>
                }
                <span class="cov0" title="0">w.Flush()</span>
        }

        // Hot Paths
        <span class="cov0" title="0">if len(summary.HotPaths) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Println("\n Hot Execution Paths")
                fmt.Println(strings.Repeat("-", 80))

                for i, path := range summary.HotPaths </span><span class="cov0" title="0">{
                        fmt.Printf("\n%d. %.1f%% of execution time (%d samples)\n",
                                i+1, path.Percentage, path.Occurrences)
                        fmt.Printf("   %s\n", path.Description)
                        fmt.Printf("   Path: %s\n", strings.Join(path.Path, "  "))
                }</span>
        }

        // Memory Leaks
        <span class="cov0" title="0">if len(summary.MemoryLeaks) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Println("\n  Potential Memory Issues")
                fmt.Println(strings.Repeat("-", 80))

                for _, leak := range summary.MemoryLeaks </span><span class="cov0" title="0">{
                        severityIcon := " "
                        switch leak.Severity </span>{
                        case "high":<span class="cov0" title="0">
                                severityIcon = ""</span>
                        case "medium":<span class="cov0" title="0">
                                severityIcon = ""</span>
                        case "low":<span class="cov0" title="0">
                                severityIcon = ""</span>
                        }

                        <span class="cov0" title="0">fmt.Printf("\n%s %s (%s)\n",
                                severityIcon,
                                leak.Function,
                                leak.Severity,
                        )
                        fmt.Printf("   Allocations: %d (%s)\n", leak.Allocations, formatBytes(leak.Bytes))
                        fmt.Printf("   %s\n", leak.Description)</span>
                }
        }

        // Optimization Suggestions
        <span class="cov0" title="0">if len(summary.Suggestions) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Println("\n Optimization Suggestions")
                fmt.Println(strings.Repeat("=", 80))

                for i, sug := range summary.Suggestions </span><span class="cov0" title="0">{
                        severityIcon := ""
                        switch sug.Severity </span>{
                        case "high":<span class="cov0" title="0">
                                severityIcon = ""</span>
                        case "medium":<span class="cov0" title="0">
                                severityIcon = ""</span>
                        case "low":<span class="cov0" title="0">
                                severityIcon = ""</span>
                        }

                        <span class="cov0" title="0">fmt.Printf("\n%d. %s [%s] %s\n", i+1, severityIcon, strings.ToUpper(sug.Type), sug.Function)
                        fmt.Printf("   Issue: %s\n", sug.Issue)
                        fmt.Printf("   Suggestion: %s\n", sug.Suggestion)
                        if sug.Impact != "" </span><span class="cov0" title="0">{
                                fmt.Printf("   Potential Impact: %s\n", sug.Impact)
                        }</span>
                }
        }

        <span class="cov0" title="0">fmt.Println("\n" + strings.Repeat("=", 80))</span>
}

// formatBytes formats bytes in human-readable format
func formatBytes(bytes int64) string <span class="cov0" title="0">{
        const unit = 1024
        if bytes &lt; unit </span><span class="cov0" title="0">{
                return fmt.Sprintf("%d B", bytes)
        }</span>
        <span class="cov0" title="0">div, exp := int64(unit), 0
        for n := bytes / unit; n &gt;= unit; n /= unit </span><span class="cov0" title="0">{
                div *= unit
                exp++
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%.1f %cB", float64(bytes)/float64(div), "KMGTPE"[exp])</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package commands

import (
        "flag"
        "fmt"
        "os"

        "github.com/alenon/gokanon/internal/dashboard"
        "github.com/alenon/gokanon/internal/storage"
)

// Serve starts the interactive web dashboard
func Serve() error <span class="cov0" title="0">{
        serveFlags := flag.NewFlagSet("serve", flag.ExitOnError)
        storageDir := serveFlags.String("storage", ".gokanon", "Storage directory for results")
        port := serveFlags.Int("port", 8080, "Port for web server")
        addr := serveFlags.String("addr", "localhost", "Address to bind to (use 0.0.0.0 for all interfaces)")
        serveFlags.Parse(os.Args[2:])

        store := storage.NewStorage(*storageDir)

        // Check if storage directory exists
        if _, err := os.Stat(*storageDir); os.IsNotExist(err) </span><span class="cov0" title="0">{
                fmt.Printf("Warning: Storage directory '%s' does not exist.\n", *storageDir)
                fmt.Println("Run some benchmarks first with: gokanon run")
                fmt.Println("\nStarting dashboard anyway...")
        }</span>

        // Create and start the dashboard server
        <span class="cov0" title="0">server := dashboard.NewServer(store, *addr, *port)

        fmt.Println("Starting interactive web dashboard...")
        fmt.Printf("Dashboard will be available at: http://%s:%d\n", *addr, *port)
        fmt.Println("\nPress Ctrl+C to stop the server")

        if err := server.Start(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start dashboard server: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package commands

import (
        "flag"
        "fmt"
        "os"
        "strings"

        "github.com/alenon/gokanon/internal/stats"
        "github.com/alenon/gokanon/internal/storage"
)

// Stats handles the 'stats' subcommand
func Stats() error <span class="cov7" title="4">{
        statsFlags := flag.NewFlagSet("stats", flag.ExitOnError)
        storageDir := statsFlags.String("storage", ".gokanon", "Storage directory for results")
        lastN := statsFlags.Int("last", 0, "Analyze last N runs (0 = all)")
        cvThreshold := statsFlags.Float64("cv-threshold", 10.0, "Coefficient of variation threshold for stability (%)")
        statsFlags.Parse(os.Args[2:])

        store := storage.NewStorage(*storageDir)
        runs, err := store.List()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to list results: %w", err)
        }</span>

        <span class="cov7" title="4">if len(runs) == 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("no benchmark results found")
        }</span>

        // Limit to last N runs if specified
        <span class="cov6" title="3">if *lastN &gt; 0 &amp;&amp; *lastN &lt; len(runs) </span><span class="cov1" title="1">{
                runs = runs[:*lastN]
        }</span>

        <span class="cov6" title="3">fmt.Printf("Statistical Analysis (%d runs)\n", len(runs))
        fmt.Printf("Runs: %s to %s\n\n",
                runs[len(runs)-1].Timestamp.Format("2006-01-02 15:04:05"),
                runs[0].Timestamp.Format("2006-01-02 15:04:05"),
        )

        // Analyze
        analyzer := stats.NewAnalyzer()
        statistics := analyzer.AnalyzeMultiple(runs)

        // Display
        fmt.Println("Benchmark Statistics:")
        fmt.Println(strings.Repeat("-", 150))

        for _, stat := range statistics </span><span class="cov10" title="6">{
                fmt.Println(stats.FormatStats(stat))

                // Show stability indicator
                if stat.IsStable(*cvThreshold) </span><span class="cov7" title="4">{
                        fmt.Print("  Stable")
                }</span> else<span class="cov4" title="2"> {
                        fmt.Print("  Variable")
                }</span>
                <span class="cov10" title="6">fmt.Println()</span>
        }

        <span class="cov6" title="3">fmt.Println(strings.Repeat("-", 150))
        fmt.Printf("\nNote: Benchmarks with CV (coefficient of variation) &lt;= %.1f%% are considered stable.\n", *cvThreshold)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package commands

import (
        "flag"
        "fmt"
        "os"

        "github.com/alenon/gokanon/internal/stats"
        "github.com/alenon/gokanon/internal/storage"
)

// Trend handles the 'trend' subcommand
func Trend() error <span class="cov1" title="1">{
        trendFlags := flag.NewFlagSet("trend", flag.ExitOnError)
        storageDir := trendFlags.String("storage", ".gokanon", "Storage directory for results")
        lastN := trendFlags.Int("last", 10, "Analyze last N runs")
        benchmark := trendFlags.String("benchmark", "", "Specific benchmark to analyze (empty = all)")
        trendFlags.Parse(os.Args[2:])

        store := storage.NewStorage(*storageDir)
        runs, err := store.List()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to list results: %w", err)
        }</span>

        <span class="cov1" title="1">if len(runs) &lt; 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("need at least 2 benchmark runs for trend analysis")
        }</span>

        // Limit to last N runs
        <span class="cov1" title="1">if *lastN &gt; 0 &amp;&amp; *lastN &lt; len(runs) </span><span class="cov0" title="0">{
                runs = runs[:*lastN]
        }</span>

        // Reverse to get chronological order
        <span class="cov1" title="1">for i := 0; i &lt; len(runs)/2; i++ </span><span class="cov1" title="1">{
                runs[i], runs[len(runs)-1-i] = runs[len(runs)-1-i], runs[i]
        }</span>

        <span class="cov1" title="1">fmt.Printf("Performance Trend Analysis (%d runs)\n", len(runs))
        fmt.Printf("Period: %s to %s\n\n",
                runs[0].Timestamp.Format("2006-01-02 15:04:05"),
                runs[len(runs)-1].Timestamp.Format("2006-01-02 15:04:05"),
        )

        analyzer := stats.NewAnalyzer()

        // Get all unique benchmark names
        benchmarkNames := make(map[string]bool)
        for _, run := range runs </span><span class="cov5" title="3">{
                for _, result := range run.Results </span><span class="cov8" title="6">{
                        if *benchmark == "" || result.Name == *benchmark </span><span class="cov8" title="6">{
                                benchmarkNames[result.Name] = true
                        }</span>
                }
        }

        // Analyze trend for each benchmark
        <span class="cov1" title="1">for name := range benchmarkNames </span><span class="cov3" title="2">{
                trend := analyzer.AnalyzeTrend(runs, name)
                if trend == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov3" title="2">fmt.Printf("Benchmark: %s\n", name)

                // Show direction
                directionSymbol := ""
                directionColor := ""
                switch trend.Direction </span>{
                case "improving":<span class="cov3" title="2">
                        directionSymbol = ""
                        directionColor = ""</span>
                case "degrading":<span class="cov0" title="0">
                        directionSymbol = ""
                        directionColor = ""</span>
                default:<span class="cov0" title="0">
                        directionColor = ""</span>
                }

                <span class="cov3" title="2">fmt.Printf("  %s Trend: %s %s (slope: %.2f ns/op per run)\n",
                        directionColor,
                        trend.Direction,
                        directionSymbol,
                        trend.TrendLine,
                )

                fmt.Printf("  Confidence: %.1f%% (R)\n", trend.Confidence*100)

                // Show data points
                fmt.Printf("  Data points: ")
                var values []float64
                for _, run := range runs </span><span class="cov8" title="6">{
                        for _, result := range run.Results </span><span class="cov10" title="9">{
                                if result.Name == name </span><span class="cov8" title="6">{
                                        values = append(values, result.NsPerOp)
                                        break</span>
                                }
                        }
                }

                // Show sparkline-like representation
                <span class="cov3" title="2">if len(values) &gt; 0 </span><span class="cov3" title="2">{
                        min, max := values[0], values[0]
                        for _, v := range values </span><span class="cov8" title="6">{
                                if v &lt; min </span><span class="cov6" title="4">{
                                        min = v
                                }</span>
                                <span class="cov8" title="6">if v &gt; max </span><span class="cov0" title="0">{
                                        max = v
                                }</span>
                        }

                        <span class="cov3" title="2">fmt.Printf("%.2f", values[0])
                        for i := 1; i &lt; len(values); i++ </span><span class="cov6" title="4">{
                                change := ((values[i] - values[i-1]) / values[i-1]) * 100
                                if change &gt; 0 </span><span class="cov0" title="0">{
                                        fmt.Printf("  %.2f (+%.1f%%)", values[i], change)
                                }</span> else<span class="cov6" title="4"> {
                                        fmt.Printf("  %.2f (%.1f%%)", values[i], change)
                                }</span>
                        }
                        <span class="cov3" title="2">fmt.Println()</span>
                }

                <span class="cov3" title="2">fmt.Println()</span>
        }

        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package compare

import (
        "fmt"
        "math"

        "github.com/alenon/gokanon/internal/models"
)

// Comparer handles benchmark comparison
type Comparer struct {
        threshold float64 // Threshold percentage to consider "same"
}

// NewComparer creates a new comparer with default threshold
func NewComparer() *Comparer <span class="cov6" title="4">{
        return &amp;Comparer{
                threshold: 5.0, // 5% threshold
        }
}</span>

// Compare compares two benchmark runs and returns comparisons for matching benchmarks
func (c *Comparer) Compare(oldRun, newRun *models.BenchmarkRun) []models.Comparison <span class="cov3" title="2">{
        // Create a map of old results for quick lookup
        oldResults := make(map[string]models.BenchmarkResult)
        for _, result := range oldRun.Results </span><span class="cov6" title="4">{
                oldResults[result.Name] = result
        }</span>

        <span class="cov3" title="2">var comparisons []models.Comparison

        // Compare each new result with corresponding old result
        for _, newResult := range newRun.Results </span><span class="cov6" title="4">{
                oldResult, exists := oldResults[newResult.Name]
                if !exists </span><span class="cov1" title="1">{
                        continue</span> // Skip benchmarks that don't exist in old run
                }

                <span class="cov5" title="3">comparison := c.compareResults(oldResult, newResult)
                comparisons = append(comparisons, comparison)</span>
        }

        <span class="cov3" title="2">return comparisons</span>
}

// compareResults compares two individual benchmark results
func (c *Comparer) compareResults(old, new models.BenchmarkResult) models.Comparison <span class="cov8" title="8">{
        delta := new.NsPerOp - old.NsPerOp
        deltaPercent := (delta / old.NsPerOp) * 100

        status := "same"
        if math.Abs(deltaPercent) &gt; c.threshold </span><span class="cov6" title="4">{
                if deltaPercent &lt; 0 </span><span class="cov3" title="2">{
                        status = "improved" // Lower is better
                }</span> else<span class="cov3" title="2"> {
                        status = "degraded"
                }</span>
        }

        <span class="cov8" title="8">return models.Comparison{
                Name:         new.Name,
                OldNsPerOp:   old.NsPerOp,
                NewNsPerOp:   new.NsPerOp,
                Delta:        delta,
                DeltaPercent: deltaPercent,
                Status:       status,
        }</span>
}

// FormatComparison formats a comparison for display
func FormatComparison(comp models.Comparison) string <span class="cov5" title="3">{
        statusSymbol := "~"
        switch comp.Status </span>{
        case "improved":<span class="cov1" title="1">
                statusSymbol = ""</span>
        case "degraded":<span class="cov1" title="1">
                statusSymbol = ""</span>
        }

        <span class="cov5" title="3">return fmt.Sprintf("%s %-40s %12.2f ns/op  %12.2f ns/op (%+.2f%%)",
                statusSymbol,
                comp.Name,
                comp.OldNsPerOp,
                comp.NewNsPerOp,
                comp.DeltaPercent,
        )</span>
}

// Summary provides a summary of the comparison
func Summary(comparisons []models.Comparison) string <span class="cov6" title="4">{
        improved := 0
        degraded := 0
        same := 0

        for _, comp := range comparisons </span><span class="cov10" title="11">{
                switch comp.Status </span>{
                case "improved":<span class="cov7" title="5">
                        improved++</span>
                case "degraded":<span class="cov5" title="3">
                        degraded++</span>
                case "same":<span class="cov5" title="3">
                        same++</span>
                }
        }

        <span class="cov6" title="4">return fmt.Sprintf("Summary: %d improved, %d degraded, %d unchanged",
                improved, degraded, same)</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package dashboard

import (
        "encoding/json"
        "fmt"
        "io"
        "log"
        "net/http"
        "sort"
        "strconv"
        "strings"
        "time"

        "github.com/alenon/gokanon/internal/storage"
)

// Server represents the dashboard web server
type Server struct {
        storage *storage.Storage
        addr    string
        port    int
}

// NewServer creates a new dashboard server
func NewServer(stor *storage.Storage, addr string, port int) *Server <span class="cov4" title="15">{
        return &amp;Server{
                storage: stor,
                addr:    addr,
                port:    port,
        }
}</span>

// Start starts the dashboard web server
func (s *Server) Start() error <span class="cov0" title="0">{
        mux := http.NewServeMux()

        // API endpoints
        mux.HandleFunc("/api/runs", s.handleRuns)
        mux.HandleFunc("/api/runs/", s.handleRunDetail)
        mux.HandleFunc("/api/trends", s.handleTrends)
        mux.HandleFunc("/api/stats", s.handleStats)
        mux.HandleFunc("/api/search", s.handleSearch)

        // Frontend
        mux.HandleFunc("/", s.handleIndex)
        mux.HandleFunc("/static/", s.handleStatic)

        addr := fmt.Sprintf("%s:%d", s.addr, s.port)
        log.Printf(" Dashboard server starting at http://%s\n", addr)
        log.Printf(" Open your browser to view interactive benchmarks\n")

        return http.ListenAndServe(addr, mux)
}</span>

// handleRuns returns a list of all benchmark runs
func (s *Server) handleRuns(w http.ResponseWriter, r *http.Request) <span class="cov6" title="53">{
        if r.Method != http.MethodGet </span><span class="cov1" title="1">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov6" title="52">runs, err := s.storage.List()
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, fmt.Sprintf("Failed to list runs: %v", err), http.StatusInternalServerError)
                return
        }</span>

        // Create a summary view for the list
        <span class="cov6" title="52">summaries := make([]map[string]interface{}, 0, len(runs))
        for _, run := range runs </span><span class="cov9" title="503">{
                summary := map[string]interface{}{
                        "id":        run.ID,
                        "timestamp": run.Timestamp.Format(time.RFC3339),
                        "package":   run.Package,
                        "goVersion": run.GoVersion,
                        "duration":  run.Duration.String(),
                        "numTests":  len(run.Results),
                }

                // Calculate average performance metrics
                if len(run.Results) &gt; 0 </span><span class="cov9" title="503">{
                        var totalNsPerOp float64
                        var totalBytesPerOp int64
                        var totalAllocsPerOp int64

                        for _, result := range run.Results </span><span class="cov10" title="504">{
                                totalNsPerOp += result.NsPerOp
                                totalBytesPerOp += result.BytesPerOp
                                totalAllocsPerOp += result.AllocsPerOp
                        }</span>

                        <span class="cov9" title="503">count := float64(len(run.Results))
                        summary["avgNsPerOp"] = totalNsPerOp / count
                        summary["avgBytesPerOp"] = float64(totalBytesPerOp) / count
                        summary["avgAllocsPerOp"] = float64(totalAllocsPerOp) / count</span>
                }

                <span class="cov9" title="503">summaries = append(summaries, summary)</span>
        }

        <span class="cov6" title="52">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(summaries)</span>
}

// handleRunDetail returns details for a specific run
func (s *Server) handleRunDetail(w http.ResponseWriter, r *http.Request) <span class="cov2" title="3">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        // Extract ID from URL path
        <span class="cov2" title="3">parts := strings.Split(r.URL.Path, "/")
        if len(parts) &lt; 4 </span><span class="cov0" title="0">{
                http.Error(w, "Invalid run ID", http.StatusBadRequest)
                return
        }</span>
        <span class="cov2" title="3">id := parts[3]

        run, err := s.storage.Load(id)
        if err != nil </span><span class="cov1" title="1">{
                http.Error(w, fmt.Sprintf("Failed to load run: %v", err), http.StatusNotFound)
                return
        }</span>

        <span class="cov2" title="2">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(run)</span>
}

// handleTrends returns trend data across multiple runs
func (s *Server) handleTrends(w http.ResponseWriter, r *http.Request) <span class="cov2" title="2">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        // Get query parameters
        <span class="cov2" title="2">benchName := r.URL.Query().Get("benchmark")
        limitStr := r.URL.Query().Get("limit")
        limit := 50 // Default limit
        if limitStr != "" </span><span class="cov2" title="2">{
                if l, err := strconv.Atoi(limitStr); err == nil &amp;&amp; l &gt; 0 </span><span class="cov2" title="2">{
                        limit = l
                }</span>
        }

        <span class="cov2" title="2">runs, err := s.storage.List()
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, fmt.Sprintf("Failed to list runs: %v", err), http.StatusInternalServerError)
                return
        }</span>

        // Limit the number of runs
        <span class="cov2" title="2">if len(runs) &gt; limit </span><span class="cov0" title="0">{
                runs = runs[:limit]
        }</span>

        // Reverse to get chronological order
        <span class="cov2" title="2">for i := 0; i &lt; len(runs)/2; i++ </span><span class="cov2" title="2">{
                runs[i], runs[len(runs)-1-i] = runs[len(runs)-1-i], runs[i]
        }</span>

        // Build trend data
        <span class="cov2" title="2">trendData := make(map[string][]map[string]interface{})

        for _, run := range runs </span><span class="cov3" title="6">{
                timestamp := run.Timestamp.Format(time.RFC3339)

                for _, result := range run.Results </span><span class="cov3" title="6">{
                        // Filter by benchmark name if specified
                        if benchName != "" &amp;&amp; result.Name != benchName </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov3" title="6">if _, exists := trendData[result.Name]; !exists </span><span class="cov2" title="2">{
                                trendData[result.Name] = make([]map[string]interface{}, 0)
                        }</span>

                        <span class="cov3" title="6">trendData[result.Name] = append(trendData[result.Name], map[string]interface{}{
                                "timestamp":   timestamp,
                                "runId":       run.ID,
                                "nsPerOp":     result.NsPerOp,
                                "bytesPerOp":  result.BytesPerOp,
                                "allocsPerOp": result.AllocsPerOp,
                                "mbPerSec":    result.MBPerSec,
                        })</span>
                }
        }

        // Calculate trend statistics
        <span class="cov2" title="2">response := make(map[string]interface{})
        response["trends"] = trendData

        // Add statistical analysis for each benchmark
        statsData := make(map[string]interface{})
        for name, points := range trendData </span><span class="cov2" title="2">{
                if len(points) &lt; 2 </span><span class="cov1" title="1">{
                        continue</span>
                }

                <span class="cov1" title="1">values := make([]float64, len(points))
                for i, point := range points </span><span class="cov3" title="5">{
                        values[i] = point["nsPerOp"].(float64)
                }</span>

                // Calculate basic statistics
                <span class="cov1" title="1">stat := calculateBasicStats(values)

                // Calculate trend (simple linear regression)
                slope := calculateSlope(values)

                statsData[name] = map[string]interface{}{
                        "mean":   stat["mean"],
                        "median": stat["median"],
                        "stdDev": stat["stdDev"],
                        "cv":     stat["cv"],
                        "min":    stat["min"],
                        "max":    stat["max"],
                        "slope":  slope,
                        "trend":  getTrendDirection(slope),
                }</span>
        }
        <span class="cov2" title="2">response["statistics"] = statsData

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(response)</span>
}

// handleStats returns statistical summaries
func (s *Server) handleStats(w http.ResponseWriter, r *http.Request) <span class="cov2" title="3">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov2" title="3">runs, err := s.storage.List()
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, fmt.Sprintf("Failed to list runs: %v", err), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov2" title="3">if len(runs) == 0 </span><span class="cov1" title="1">{
                w.Header().Set("Content-Type", "application/json")
                json.NewEncoder(w).Encode(map[string]interface{}{
                        "totalRuns":  0,
                        "totalTests": 0,
                        "benchmarks": []string{},
                        "dateRange":  map[string]string{},
                        "recentRuns": []interface{}{},
                })
                return
        }</span>

        // Collect all unique benchmark names
        <span class="cov2" title="2">benchmarkNames := make(map[string]bool)
        totalTests := 0

        for _, run := range runs </span><span class="cov3" title="4">{
                totalTests += len(run.Results)
                for _, result := range run.Results </span><span class="cov3" title="7">{
                        benchmarkNames[result.Name] = true
                }</span>
        }

        // Convert map to sorted slice
        <span class="cov2" title="2">uniqueBenchmarks := make([]string, 0, len(benchmarkNames))
        for name := range benchmarkNames </span><span class="cov2" title="3">{
                uniqueBenchmarks = append(uniqueBenchmarks, name)
        }</span>
        <span class="cov2" title="2">sort.Strings(uniqueBenchmarks)

        // Date range
        oldest := runs[len(runs)-1].Timestamp
        newest := runs[0].Timestamp

        // Recent runs (last 10)
        recentCount := 10
        if len(runs) &lt; recentCount </span><span class="cov2" title="2">{
                recentCount = len(runs)
        }</span>
        <span class="cov2" title="2">recentRuns := make([]map[string]interface{}, recentCount)
        for i := 0; i &lt; recentCount; i++ </span><span class="cov3" title="4">{
                run := runs[i]
                recentRuns[i] = map[string]interface{}{
                        "id":        run.ID,
                        "timestamp": run.Timestamp.Format(time.RFC3339),
                        "package":   run.Package,
                        "numTests":  len(run.Results),
                }
        }</span>

        <span class="cov2" title="2">response := map[string]interface{}{
                "totalRuns":  len(runs),
                "totalTests": totalTests,
                "benchmarks": uniqueBenchmarks,
                "dateRange": map[string]string{
                        "oldest": oldest.Format(time.RFC3339),
                        "newest": newest.Format(time.RFC3339),
                },
                "recentRuns": recentRuns,
        }

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(response)</span>
}

// handleSearch searches for benchmark runs and results
func (s *Server) handleSearch(w http.ResponseWriter, r *http.Request) <span class="cov3" title="5">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov3" title="5">query := strings.ToLower(r.URL.Query().Get("q"))
        if query == "" </span><span class="cov1" title="1">{
                http.Error(w, "Missing search query parameter 'q'", http.StatusBadRequest)
                return
        }</span>

        <span class="cov3" title="4">runs, err := s.storage.List()
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, fmt.Sprintf("Failed to list runs: %v", err), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov3" title="4">results := make([]map[string]interface{}, 0)

        for _, run := range runs </span><span class="cov3" title="4">{
                // Search in package name, ID, or benchmark names
                if strings.Contains(strings.ToLower(run.Package), query) ||
                        strings.Contains(strings.ToLower(run.ID), query) </span><span class="cov2" title="2">{

                        results = append(results, map[string]interface{}{
                                "type":      "run",
                                "id":        run.ID,
                                "timestamp": run.Timestamp.Format(time.RFC3339),
                                "package":   run.Package,
                                "numTests":  len(run.Results),
                        })
                        continue</span>
                }

                // Search in benchmark result names
                <span class="cov2" title="2">for _, result := range run.Results </span><span class="cov3" title="4">{
                        if strings.Contains(strings.ToLower(result.Name), query) </span><span class="cov2" title="2">{
                                results = append(results, map[string]interface{}{
                                        "type":      "benchmark",
                                        "runId":     run.ID,
                                        "timestamp": run.Timestamp.Format(time.RFC3339),
                                        "name":      result.Name,
                                        "nsPerOp":   result.NsPerOp,
                                })
                        }</span>
                }
        }

        <span class="cov3" title="4">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]interface{}{
                "query":   query,
                "count":   len(results),
                "results": results,
        })</span>
}

// handleIndex serves the main dashboard HTML
func (s *Server) handleIndex(w http.ResponseWriter, r *http.Request) <span class="cov2" title="3">{
        if r.URL.Path != "/" </span><span class="cov1" title="1">{
                http.NotFound(w, r)
                return
        }</span>

        <span class="cov2" title="2">w.Header().Set("Content-Type", "text/html; charset=utf-8")
        io.WriteString(w, indexHTML)</span>
}

// handleStatic serves static assets (CSS, JS)
func (s *Server) handleStatic(w http.ResponseWriter, r *http.Request) <span class="cov3" title="5">{
        path := r.URL.Path

        switch </span>{
        case strings.HasSuffix(path, ".css"):<span class="cov2" title="2">
                w.Header().Set("Content-Type", "text/css")
                io.WriteString(w, stylesCSS)</span>
        case strings.HasSuffix(path, ".js"):<span class="cov2" title="2">
                w.Header().Set("Content-Type", "application/javascript")
                if strings.Contains(path, "app.js") </span><span class="cov2" title="2">{
                        io.WriteString(w, appJS)
                }</span>
        default:<span class="cov1" title="1">
                http.NotFound(w, r)</span>
        }
}

// getTrendDirection returns the trend direction based on slope
func getTrendDirection(slope float64) string <span class="cov3" title="6">{
        if slope &gt; 5 </span><span class="cov2" title="2">{
                return "degrading"
        }</span> else<span class="cov3" title="4"> if slope &lt; -5 </span><span class="cov1" title="1">{
                return "improving"
        }</span>
        <span class="cov2" title="3">return "stable"</span>
}

// calculateBasicStats calculates basic statistical measures for a set of values
func calculateBasicStats(values []float64) map[string]float64 <span class="cov3" title="5">{
        if len(values) == 0 </span><span class="cov1" title="1">{
                return map[string]float64{
                        "mean":   0,
                        "median": 0,
                        "stdDev": 0,
                        "cv":     0,
                        "min":    0,
                        "max":    0,
                }
        }</span>

        // Sort for median calculation
        <span class="cov3" title="4">sorted := make([]float64, len(values))
        copy(sorted, values)
        sort.Float64s(sorted)

        // Calculate mean
        sum := 0.0
        for _, v := range values </span><span class="cov4" title="13">{
                sum += v
        }</span>
        <span class="cov3" title="4">mean := sum / float64(len(values))

        // Calculate median
        var median float64
        if len(sorted)%2 == 0 </span><span class="cov1" title="1">{
                median = (sorted[len(sorted)/2-1] + sorted[len(sorted)/2]) / 2
        }</span> else<span class="cov2" title="3"> {
                median = sorted[len(sorted)/2]
        }</span>

        // Calculate standard deviation
        <span class="cov3" title="4">sumSquaredDiff := 0.0
        for _, v := range values </span><span class="cov4" title="13">{
                diff := v - mean
                sumSquaredDiff += diff * diff
        }</span>
        <span class="cov3" title="4">variance := sumSquaredDiff / float64(len(values))
        stdDev := 0.0
        if variance &gt; 0 </span><span class="cov2" title="3">{
                stdDev = variance // simplified, not taking sqrt for performance
        }</span>

        // Calculate coefficient of variation
        <span class="cov3" title="4">cv := 0.0
        if mean != 0 </span><span class="cov3" title="4">{
                cv = (stdDev / mean) * 100
        }</span>

        <span class="cov3" title="4">return map[string]float64{
                "mean":   mean,
                "median": median,
                "stdDev": stdDev,
                "cv":     cv,
                "min":    sorted[0],
                "max":    sorted[len(sorted)-1],
        }</span>
}

// calculateSlope calculates the slope of a simple linear regression
func calculateSlope(values []float64) float64 <span class="cov3" title="6">{
        n := float64(len(values))
        if n &lt; 2 </span><span class="cov2" title="2">{
                return 0
        }</span>

        // Create x values (indices)
        <span class="cov3" title="4">var sumX, sumY, sumXY, sumX2 float64
        for i, y := range values </span><span class="cov5" title="19">{
                x := float64(i)
                sumX += x
                sumY += y
                sumXY += x * y
                sumX2 += x * x
        }</span>

        // Calculate slope
        <span class="cov3" title="4">denominator := n*sumX2 - sumX*sumX
        if denominator == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov3" title="4">slope := (n*sumXY - sumX*sumY) / denominator
        return slope</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package doctor

import (
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "runtime"
        "strings"

        "github.com/alenon/gokanon/internal/storage"
        "github.com/alenon/gokanon/internal/ui"
)

// CheckResult represents the result of a diagnostic check
type CheckResult struct {
        Name        string
        Passed      bool
        Message     string
        Suggestions []string
}

// RunDiagnostics runs all diagnostic checks
func RunDiagnostics() []CheckResult <span class="cov3" title="2">{
        results := []CheckResult{}

        ui.PrintHeader("Running gokanon diagnostics...")
        fmt.Println()

        // Check 1: Go installation
        results = append(results, checkGoInstallation())

        // Check 2: Go test command
        results = append(results, checkGoTest())

        // Check 3: Storage directory
        results = append(results, checkStorageDirectory())

        // Check 4: Storage integrity
        results = append(results, checkStorageIntegrity())

        // Check 5: Benchmark files
        results = append(results, checkBenchmarkFiles())

        // Check 6: Git repository (optional)
        results = append(results, checkGitRepo())

        // Check 7: Available memory
        results = append(results, checkSystemResources())

        return results
}</span>

// PrintResults prints the diagnostic results
func PrintResults(results []CheckResult) <span class="cov6" title="4">{
        fmt.Println()
        ui.PrintSection(ui.ChartEmoji, "Diagnostic Results")
        fmt.Println()

        passedCount := 0
        failedCount := 0

        for _, result := range results </span><span class="cov10" title="11">{
                if result.Passed </span><span class="cov9" title="9">{
                        passedCount++
                        ui.PrintSuccess("%s: %s", result.Name, result.Message)
                }</span> else<span class="cov3" title="2"> {
                        failedCount++
                        ui.PrintError("%s: %s", result.Name, result.Message)
                        if len(result.Suggestions) &gt; 0 </span><span class="cov3" title="2">{
                                for _, suggestion := range result.Suggestions </span><span class="cov6" title="4">{
                                        fmt.Printf("  %s %s\n", ui.Info(ui.ArrowIcon), suggestion)
                                }</span>
                        }
                }
                <span class="cov10" title="11">fmt.Println()</span>
        }

        <span class="cov6" title="4">fmt.Println()
        ui.PrintHeader("Summary")
        fmt.Printf("%s %d checks passed\n", ui.Success(ui.CheckEmoji), passedCount)
        if failedCount &gt; 0 </span><span class="cov3" title="2">{
                fmt.Printf("%s %d checks failed\n", ui.Error(ui.CrossEmoji), failedCount)
        }</span>
        <span class="cov6" title="4">fmt.Println()

        if failedCount == 0 </span><span class="cov3" title="2">{
                ui.PrintSuccess("All checks passed! Your gokanon setup is healthy.")
        }</span> else<span class="cov3" title="2"> {
                ui.PrintWarning("Some checks failed. Please review the suggestions above.")
        }</span>
}

func checkGoInstallation() CheckResult <span class="cov7" title="5">{
        cmd := exec.Command("go", "version")
        output, err := cmd.CombinedOutput()

        if err != nil </span><span class="cov0" title="0">{
                return CheckResult{
                        Name:    "Go Installation",
                        Passed:  false,
                        Message: "Go is not installed or not in PATH",
                        Suggestions: []string{
                                "Install Go from https://golang.org/dl/",
                                "Ensure Go is in your PATH environment variable",
                        },
                }
        }</span>

        <span class="cov7" title="5">version := strings.TrimSpace(string(output))
        return CheckResult{
                Name:    "Go Installation",
                Passed:  true,
                Message: version,
        }</span>
}

func checkGoTest() CheckResult <span class="cov8" title="7">{
        cmd := exec.Command("go", "test", "-bench=.", "-run=^$", "-count=1")
        cmd.Env = append(os.Environ(), "GOKANON_DRY_RUN=1")

        // Don't actually run tests, just check if the command is available
        err := cmd.Start()
        if err != nil </span><span class="cov0" title="0">{
                return CheckResult{
                        Name:    "Go Test Command",
                        Passed:  false,
                        Message: "Cannot execute 'go test' command",
                        Suggestions: []string{
                                "Ensure Go toolchain is properly installed",
                                "Check if current directory is a valid Go module",
                        },
                }
        }</span>
        <span class="cov8" title="7">cmd.Process.Kill()

        return CheckResult{
                Name:    "Go Test Command",
                Passed:  true,
                Message: "'go test' command is available",
        }</span>
}

func checkStorageDirectory() CheckResult <span class="cov7" title="6">{
        storageDir := ".gokanon"

        info, err := os.Stat(storageDir)
        if err != nil </span><span class="cov6" title="4">{
                if os.IsNotExist(err) </span><span class="cov6" title="4">{
                        return CheckResult{
                                Name:    "Storage Directory",
                                Passed:  true,
                                Message: fmt.Sprintf("Storage directory will be created at: %s", storageDir),
                        }
                }</span>

                <span class="cov0" title="0">return CheckResult{
                        Name:    "Storage Directory",
                        Passed:  false,
                        Message: fmt.Sprintf("Cannot access storage directory: %v", err),
                        Suggestions: []string{
                                "Check file permissions on " + storageDir,
                                "Ensure parent directory exists and is writable",
                        },
                }</span>
        }

        <span class="cov3" title="2">if !info.IsDir() </span><span class="cov1" title="1">{
                return CheckResult{
                        Name:    "Storage Directory",
                        Passed:  false,
                        Message: fmt.Sprintf("%s exists but is not a directory", storageDir),
                        Suggestions: []string{
                                "Remove the file: rm " + storageDir,
                                "Gobench will create the directory automatically",
                        },
                }
        }</span>

        <span class="cov1" title="1">return CheckResult{
                Name:    "Storage Directory",
                Passed:  true,
                Message: fmt.Sprintf("Storage directory exists at: %s", storageDir),
        }</span>
}

func checkStorageIntegrity() CheckResult <span class="cov7" title="6">{
        store := storage.NewStorage(".gokanon")
        runs, err := store.List()
        if err != nil </span><span class="cov0" title="0">{
                return CheckResult{
                        Name:    "Storage Integrity",
                        Passed:  false,
                        Message: fmt.Sprintf("Cannot read storage: %v", err),
                        Suggestions: []string{
                                "Run 'gokanon list' to see detailed error",
                                "Backup and remove .gokanon directory if corrupted",
                        },
                }
        }</span>

        <span class="cov7" title="6">if len(runs) == 0 </span><span class="cov7" title="5">{
                return CheckResult{
                        Name:    "Storage Integrity",
                        Passed:  true,
                        Message: "No benchmark runs stored yet",
                }
        }</span>

        // Check if we can load a recent run
        <span class="cov1" title="1">_, err = store.Load(runs[0].ID)
        if err != nil </span><span class="cov0" title="0">{
                return CheckResult{
                        Name:    "Storage Integrity",
                        Passed:  false,
                        Message: fmt.Sprintf("Storage may be corrupted: %v", err),
                        Suggestions: []string{
                                "Try deleting corrupted runs manually",
                                "Backup and recreate .gokanon directory if needed",
                        },
                }
        }</span>

        <span class="cov1" title="1">return CheckResult{
                Name:    "Storage Integrity",
                Passed:  true,
                Message: fmt.Sprintf("Storage is healthy with %d run(s)", len(runs)),
        }</span>
}

func checkBenchmarkFiles() CheckResult <span class="cov8" title="7">{
        // Look for *_test.go files with Benchmark functions
        matches, err := filepath.Glob("*_test.go")
        if err != nil </span><span class="cov0" title="0">{
                return CheckResult{
                        Name:    "Benchmark Files",
                        Passed:  false,
                        Message: fmt.Sprintf("Error searching for test files: %v", err),
                }
        }</span>

        <span class="cov8" title="7">if len(matches) == 0 </span><span class="cov1" title="1">{
                return CheckResult{
                        Name:    "Benchmark Files",
                        Passed:  false,
                        Message: "No test files found in current directory",
                        Suggestions: []string{
                                "Create benchmark files with *_test.go naming",
                                "Benchmark functions should start with 'Benchmark' (e.g., BenchmarkMyFunc)",
                                "Run 'gokanon run -pkg=./...' to search subdirectories",
                        },
                }
        }</span>

        // Check if any file contains "Benchmark" functions
        <span class="cov7" title="6">hasBenchmarks := false
        for _, file := range matches </span><span class="cov7" title="6">{
                content, err := os.ReadFile(file)
                if err != nil </span><span class="cov1" title="1">{
                        continue</span>
                }
                <span class="cov7" title="5">if strings.Contains(string(content), "func Benchmark") </span><span class="cov6" title="4">{
                        hasBenchmarks = true
                        break</span>
                }
        }

        <span class="cov7" title="6">if !hasBenchmarks </span><span class="cov3" title="2">{
                return CheckResult{
                        Name:    "Benchmark Files",
                        Passed:  false,
                        Message: fmt.Sprintf("Found %d test file(s) but no benchmark functions", len(matches)),
                        Suggestions: []string{
                                "Add benchmark functions: func BenchmarkXxx(b *testing.B) { ... }",
                                "See https://golang.org/pkg/testing/#hdr-Benchmarks for examples",
                        },
                }
        }</span>

        <span class="cov6" title="4">return CheckResult{
                Name:    "Benchmark Files",
                Passed:  true,
                Message: fmt.Sprintf("Found %d test file(s) with benchmarks", len(matches)),
        }</span>
}

func checkGitRepo() CheckResult <span class="cov7" title="5">{
        cmd := exec.Command("git", "rev-parse", "--git-dir")
        err := cmd.Run()

        if err != nil </span><span class="cov1" title="1">{
                return CheckResult{
                        Name:    "Git Repository (optional)",
                        Passed:  true,
                        Message: "Not a git repository (this is optional)",
                }
        }</span>

        <span class="cov6" title="4">return CheckResult{
                Name:    "Git Repository",
                Passed:  true,
                Message: "Git repository detected",
        }</span>
}

func checkSystemResources() CheckResult <span class="cov6" title="4">{
        var m runtime.MemStats
        runtime.ReadMemStats(&amp;m)

        totalMemMB := m.Sys / 1024 / 1024

        if totalMemMB &lt; 100 </span><span class="cov6" title="4">{
                return CheckResult{
                        Name:    "System Resources",
                        Passed:  false,
                        Message: fmt.Sprintf("Low memory available: %d MB", totalMemMB),
                        Suggestions: []string{
                                "Close other applications to free up memory",
                                "Benchmarking may be unreliable with low memory",
                        },
                }
        }</span>

        <span class="cov0" title="0">return CheckResult{
                Name:    "System Resources",
                Passed:  true,
                Message: fmt.Sprintf("System memory: %d MB, Go runtime: %s", totalMemMB, runtime.Version()),
        }</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package export

import (
        "encoding/csv"
        "fmt"
        "html/template"
        "os"
        "strings"

        "github.com/alenon/gokanon/internal/models"
)

// Exporter handles exporting benchmark comparisons to various formats
type Exporter struct{}

// NewExporter creates a new exporter
func NewExporter() *Exporter <span class="cov7" title="8">{
        return &amp;Exporter{}
}</span>

// ToCSV exports comparisons to CSV format
func (e *Exporter) ToCSV(comparisons []models.Comparison, filename string) error <span class="cov4" title="3">{
        file, err := os.Create(filename)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to create CSV file: %w", err)
        }</span>
        <span class="cov3" title="2">defer file.Close()

        writer := csv.NewWriter(file)
        defer writer.Flush()

        // Write header
        header := []string{"Benchmark", "Old (ns/op)", "New (ns/op)", "Delta (ns/op)", "Delta (%)", "Status"}
        if err := writer.Write(header); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Write data
        <span class="cov3" title="2">for _, comp := range comparisons </span><span class="cov3" title="2">{
                record := []string{
                        comp.Name,
                        fmt.Sprintf("%.2f", comp.OldNsPerOp),
                        fmt.Sprintf("%.2f", comp.NewNsPerOp),
                        fmt.Sprintf("%.2f", comp.Delta),
                        fmt.Sprintf("%.2f", comp.DeltaPercent),
                        comp.Status,
                }
                if err := writer.Write(record); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov3" title="2">return nil</span>
}

// ToMarkdown exports comparisons to Markdown format
func (e *Exporter) ToMarkdown(comparisons []models.Comparison, oldID, newID string, filename string) error <span class="cov3" title="2">{
        var sb strings.Builder

        sb.WriteString("# Benchmark Comparison\n\n")
        sb.WriteString(fmt.Sprintf("Comparing: `%s` vs `%s`\n\n", oldID, newID))
        sb.WriteString("| Status | Benchmark | Old (ns/op) | New (ns/op) | Delta | Delta (%) |\n")
        sb.WriteString("|--------|-----------|-------------|-------------|-------|----------|\n")

        for _, comp := range comparisons </span><span class="cov5" title="4">{
                status := ""
                switch comp.Status </span>{
                case "improved":<span class="cov3" title="2">
                        status = ""</span>
                case "degraded":<span class="cov1" title="1">
                        status = ""</span>
                }

                <span class="cov5" title="4">sb.WriteString(fmt.Sprintf("| %s | %s | %.2f | %.2f | %.2f | %+.2f%% |\n",
                        status,
                        comp.Name,
                        comp.OldNsPerOp,
                        comp.NewNsPerOp,
                        comp.Delta,
                        comp.DeltaPercent,
                ))</span>
        }

        // Add summary
        <span class="cov3" title="2">improved, degraded, same := countStatus(comparisons)
        sb.WriteString(fmt.Sprintf("\n## Summary\n\n"))
        sb.WriteString(fmt.Sprintf("-  Improved: %d\n", improved))
        sb.WriteString(fmt.Sprintf("-  Degraded: %d\n", degraded))
        sb.WriteString(fmt.Sprintf("-  Unchanged: %d\n", same))

        return os.WriteFile(filename, []byte(sb.String()), 0644)</span>
}

// ToHTML exports comparisons to HTML format
func (e *Exporter) ToHTML(comparisons []models.Comparison, oldID, newID, oldTimestamp, newTimestamp string, filename string) error <span class="cov3" title="2">{
        tmpl := `&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;Benchmark Comparison Report&lt;/title&gt;
    &lt;script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"&gt;&lt;/script&gt;
    &lt;style&gt;
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary-color: #4f46e5;
            --success-color: #10b981;
            --danger-color: #ef4444;
            --warning-color: #f59e0b;
            --neutral-color: #6b7280;
            --bg-color: #f9fafb;
            --card-bg: #ffffff;
            --text-primary: #111827;
            --text-secondary: #6b7280;
            --border-color: #e5e7eb;
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            --shadow-lg: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: var(--text-primary);
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 40px;
            margin-bottom: 30px;
            box-shadow: var(--shadow-lg);
            animation: slideDown 0.5s ease-out;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        h1 {
            font-size: 2.5rem;
            font-weight: 800;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }

        .subtitle {
            color: var(--text-secondary);
            font-size: 1.1rem;
        }

        .metadata {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            padding: 20px;
            border-radius: 12px;
            margin: 20px 0;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
        }

        .metadata-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .metadata-item strong {
            color: var(--text-primary);
            font-weight: 600;
        }

        .metadata-item span {
            color: var(--text-secondary);
        }

        .summary {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .summary-card {
            background: var(--card-bg);
            padding: 30px;
            border-radius: 16px;
            text-align: center;
            box-shadow: var(--shadow);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .summary-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, var(--card-color) 0%, var(--card-color-light) 100%);
        }

        .summary-card:hover {
            transform: translateY(-5px);
            box-shadow: var(--shadow-lg);
        }

        .summary-card.improved-card {
            --card-color: var(--success-color);
            --card-color-light: #34d399;
        }

        .summary-card.degraded-card {
            --card-color: var(--danger-color);
            --card-color-light: #f87171;
        }

        .summary-card.same-card {
            --card-color: var(--neutral-color);
            --card-color-light: #9ca3af;
        }

        .summary-card h3 {
            font-size: 0.875rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-secondary);
            margin-bottom: 15px;
        }

        .summary-card .number {
            font-size: 3rem;
            font-weight: 800;
            color: var(--card-color);
            line-height: 1;
        }

        .summary-card .label {
            margin-top: 10px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .chart-container {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 30px;
            margin: 30px 0;
            box-shadow: var(--shadow);
        }

        .chart-container h2 {
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 20px;
            color: var(--text-primary);
        }

        .chart-wrapper {
            position: relative;
            height: 400px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            background: var(--card-bg);
            border-radius: 16px;
            overflow: hidden;
            box-shadow: var(--shadow);
            margin: 30px 0;
        }

        thead {
            background: linear-gradient(135deg, var(--primary-color) 0%, #6366f1 100%);
        }

        th {
            color: white;
            padding: 16px;
            text-align: left;
            font-weight: 600;
            font-size: 0.875rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        tbody tr {
            border-bottom: 1px solid var(--border-color);
            transition: background-color 0.2s ease;
        }

        tbody tr:hover {
            background-color: #f9fafb;
        }

        tbody tr:last-child {
            border-bottom: none;
        }

        td {
            padding: 16px;
            font-size: 0.95rem;
        }

        .status {
            font-size: 1.5rem;
        }

        .benchmark-name {
            font-weight: 600;
            color: var(--text-primary);
        }

        .metric {
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
        }

        .badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.875rem;
            font-weight: 600;
        }

        .badge.improved {
            background-color: #d1fae5;
            color: var(--success-color);
        }

        .badge.degraded {
            background-color: #fee2e2;
            color: var(--danger-color);
        }

        .badge.same {
            background-color: #f3f4f6;
            color: var(--neutral-color);
        }

        .footer {
            text-align: center;
            padding: 40px 20px;
            color: white;
            font-size: 0.875rem;
        }

        .footer a {
            color: white;
            text-decoration: underline;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.75rem;
            }

            .summary {
                grid-template-columns: 1fr;
            }

            table {
                font-size: 0.875rem;
            }

            th, td {
                padding: 12px 8px;
            }

            .chart-wrapper {
                height: 300px;
            }
        }

        .loading {
            text-align: center;
            padding: 60px 20px;
            color: var(--text-secondary);
        }

        .spinner {
            border: 3px solid #f3f4f6;
            border-top: 3px solid var(--primary-color);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class="container"&gt;
        &lt;header&gt;
            &lt;h1&gt; Benchmark Comparison Report&lt;/h1&gt;
            &lt;p class="subtitle"&gt;Performance Analysis &amp; Regression Detection&lt;/p&gt;
        &lt;/header&gt;

        &lt;div class="metadata"&gt;
            &lt;div class="metadata-item"&gt;
                &lt;strong&gt; Old Run:&lt;/strong&gt;
                &lt;span&gt;{{.OldID}} ({{.OldTimestamp}})&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class="metadata-item"&gt;
                &lt;strong&gt; New Run:&lt;/strong&gt;
                &lt;span&gt;{{.NewID}} ({{.NewTimestamp}})&lt;/span&gt;
            &lt;/div&gt;
        &lt;/div&gt;

        &lt;div class="summary"&gt;
            &lt;div class="summary-card improved-card"&gt;
                &lt;h3&gt;Improved&lt;/h3&gt;
                &lt;div class="number"&gt;{{.Improved}}&lt;/div&gt;
                &lt;div class="label"&gt;Faster benchmarks&lt;/div&gt;
            &lt;/div&gt;
            &lt;div class="summary-card degraded-card"&gt;
                &lt;h3&gt;Degraded&lt;/h3&gt;
                &lt;div class="number"&gt;{{.Degraded}}&lt;/div&gt;
                &lt;div class="label"&gt;Slower benchmarks&lt;/div&gt;
            &lt;/div&gt;
            &lt;div class="summary-card same-card"&gt;
                &lt;h3&gt;Unchanged&lt;/h3&gt;
                &lt;div class="number"&gt;{{.Same}}&lt;/div&gt;
                &lt;div class="label"&gt;Stable benchmarks&lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;

        &lt;div class="chart-container"&gt;
            &lt;h2&gt;Performance Comparison&lt;/h2&gt;
            &lt;div class="chart-wrapper"&gt;
                &lt;canvas id="performanceChart"&gt;&lt;/canvas&gt;
            &lt;/div&gt;
        &lt;/div&gt;

        &lt;div class="chart-container"&gt;
            &lt;h2&gt;Delta Distribution&lt;/h2&gt;
            &lt;div class="chart-wrapper"&gt;
                &lt;canvas id="deltaChart"&gt;&lt;/canvas&gt;
            &lt;/div&gt;
        &lt;/div&gt;

        &lt;table&gt;
            &lt;thead&gt;
                &lt;tr&gt;
                    &lt;th&gt;Status&lt;/th&gt;
                    &lt;th&gt;Benchmark&lt;/th&gt;
                    &lt;th&gt;Old (ns/op)&lt;/th&gt;
                    &lt;th&gt;New (ns/op)&lt;/th&gt;
                    &lt;th&gt;Delta (ns/op)&lt;/th&gt;
                    &lt;th&gt;Delta (%)&lt;/th&gt;
                &lt;/tr&gt;
            &lt;/thead&gt;
            &lt;tbody&gt;
                {{range .Comparisons}}
                &lt;tr&gt;
                    &lt;td class="status"&gt;
                        {{if eq .Status "improved"}}{{else if eq .Status "degraded"}}{{else}}{{end}}
                    &lt;/td&gt;
                    &lt;td class="benchmark-name"&gt;{{.Name}}&lt;/td&gt;
                    &lt;td class="metric"&gt;{{printf "%.2f" .OldNsPerOp}}&lt;/td&gt;
                    &lt;td class="metric"&gt;{{printf "%.2f" .NewNsPerOp}}&lt;/td&gt;
                    &lt;td class="metric"&gt;{{printf "%+.2f" .Delta}}&lt;/td&gt;
                    &lt;td&gt;
                        &lt;span class="badge {{.Status}}"&gt;{{printf "%+.2f%%" .DeltaPercent}}&lt;/span&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
                {{end}}
            &lt;/tbody&gt;
        &lt;/table&gt;

        &lt;div class="footer"&gt;
            &lt;p&gt;Generated by &lt;a href="https://github.com/alenon/gokanon" target="_blank"&gt;gokanon&lt;/a&gt;&lt;/p&gt;
            &lt;p&gt;A powerful CLI tool for Go benchmark testing and performance analysis&lt;/p&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;script&gt;
        // Prepare data for charts
        const comparisons = [
            {{range .Comparisons}}
            {
                name: "{{.Name}}",
                oldValue: {{.OldNsPerOp}},
                newValue: {{.NewNsPerOp}},
                delta: {{.Delta}},
                deltaPercent: {{.DeltaPercent}},
                status: "{{.Status}}"
            },
            {{end}}
        ];

        // Performance Comparison Chart
        const ctx1 = document.getElementById('performanceChart').getContext('2d');
        new Chart(ctx1, {
            type: 'bar',
            data: {
                labels: comparisons.map(c =&gt; c.name.length &gt; 30 ? c.name.substring(0, 30) + '...' : c.name),
                datasets: [
                    {
                        label: 'Old (ns/op)',
                        data: comparisons.map(c =&gt; c.oldValue),
                        backgroundColor: 'rgba(107, 114, 128, 0.7)',
                        borderColor: 'rgba(107, 114, 128, 1)',
                        borderWidth: 2
                    },
                    {
                        label: 'New (ns/op)',
                        data: comparisons.map(c =&gt; c.newValue),
                        backgroundColor: comparisons.map(c =&gt;
                            c.status === 'improved' ? 'rgba(16, 185, 129, 0.7)' :
                            c.status === 'degraded' ? 'rgba(239, 68, 68, 0.7)' :
                            'rgba(107, 114, 128, 0.7)'
                        ),
                        borderColor: comparisons.map(c =&gt;
                            c.status === 'improved' ? 'rgba(16, 185, 129, 1)' :
                            c.status === 'degraded' ? 'rgba(239, 68, 68, 1)' :
                            'rgba(107, 114, 128, 1)'
                        ),
                        borderWidth: 2
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'top',
                        labels: {
                            font: {
                                size: 14,
                                weight: '600'
                            }
                        }
                    },
                    tooltip: {
                        callbacks: {
                            afterLabel: function(context) {
                                const index = context.dataIndex;
                                const comp = comparisons[index];
                                return 'Delta: ' + comp.deltaPercent.toFixed(2) + '%';
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Nanoseconds per operation',
                            font: {
                                size: 14,
                                weight: '600'
                            }
                        }
                    }
                }
            }
        });

        // Delta Distribution Chart
        const ctx2 = document.getElementById('deltaChart').getContext('2d');
        new Chart(ctx2, {
            type: 'bar',
            data: {
                labels: comparisons.map(c =&gt; c.name.length &gt; 30 ? c.name.substring(0, 30) + '...' : c.name),
                datasets: [{
                    label: 'Performance Delta (%)',
                    data: comparisons.map(c =&gt; c.deltaPercent),
                    backgroundColor: comparisons.map(c =&gt;
                        c.deltaPercent &lt; 0 ? 'rgba(16, 185, 129, 0.7)' :
                        c.deltaPercent &gt; 0 ? 'rgba(239, 68, 68, 0.7)' :
                        'rgba(107, 114, 128, 0.7)'
                    ),
                    borderColor: comparisons.map(c =&gt;
                        c.deltaPercent &lt; 0 ? 'rgba(16, 185, 129, 1)' :
                        c.deltaPercent &gt; 0 ? 'rgba(239, 68, 68, 1)' :
                        'rgba(107, 114, 128, 1)'
                    ),
                    borderWidth: 2
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return 'Delta: ' + context.parsed.y.toFixed(2) + '%';
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        title: {
                            display: true,
                            text: 'Performance Change (%)',
                            font: {
                                size: 14,
                                weight: '600'
                            }
                        },
                        ticks: {
                            callback: function(value) {
                                return value + '%';
                            }
                        }
                    }
                }
            }
        });
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;`

        t, err := template.New("report").Parse(tmpl)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse template: %w", err)
        }</span>

        <span class="cov3" title="2">improved, degraded, same := countStatus(comparisons)

        data := struct {
                OldID        string
                NewID        string
                OldTimestamp string
                NewTimestamp string
                Comparisons  []models.Comparison
                Improved     int
                Degraded     int
                Same         int
        }{
                OldID:        oldID,
                NewID:        newID,
                OldTimestamp: oldTimestamp,
                NewTimestamp: newTimestamp,
                Comparisons:  comparisons,
                Improved:     improved,
                Degraded:     degraded,
                Same:         same,
        }

        file, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create HTML file: %w", err)
        }</span>
        <span class="cov3" title="2">defer file.Close()

        return t.Execute(file, data)</span>
}

// countStatus counts the number of each status type
func countStatus(comparisons []models.Comparison) (improved, degraded, same int) <span class="cov6" title="6">{
        for _, comp := range comparisons </span><span class="cov10" title="17">{
                switch comp.Status </span>{
                case "improved":<span class="cov7" title="8">
                        improved++</span>
                case "degraded":<span class="cov6" title="5">
                        degraded++</span>
                case "same":<span class="cov5" title="4">
                        same++</span>
                }
        }
        <span class="cov6" title="6">return</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package interactive

import (
        "fmt"
        "io"
        "strings"

        "github.com/alenon/gokanon/internal/ui"
        "github.com/chzyer/readline"
)

// Session represents an interactive gokanon session
type Session struct {
        rl       *readline.Instance
        commands map[string]CommandHandler
}

// CommandHandler is a function that handles a command
type CommandHandler func(args []string) error

// New creates a new interactive session
func New() (*Session, error) <span class="cov7" title="26">{
        completer := readline.NewPrefixCompleter(
                readline.PcItem("run",
                        readline.PcItem("-bench="),
                        readline.PcItem("-pkg="),
                        readline.PcItem("-profile="),
                        readline.PcItem("-benchtime="),
                        readline.PcItem("-count="),
                ),
                readline.PcItem("list"),
                readline.PcItem("compare",
                        readline.PcItem("--latest"),
                ),
                readline.PcItem("export",
                        readline.PcItem("--latest"),
                        readline.PcItem("-format=html"),
                        readline.PcItem("-format=csv"),
                        readline.PcItem("-format=markdown"),
                        readline.PcItem("-format=json"),
                ),
                readline.PcItem("stats",
                        readline.PcItem("-last="),
                ),
                readline.PcItem("trend",
                        readline.PcItem("-last="),
                ),
                readline.PcItem("check",
                        readline.PcItem("--latest"),
                        readline.PcItem("-threshold="),
                ),
                readline.PcItem("flamegraph"),
                readline.PcItem("serve",
                        readline.PcItem("-port="),
                ),
                readline.PcItem("delete"),
                readline.PcItem("doctor"),
                readline.PcItem("help"),
                readline.PcItem("clear"),
                readline.PcItem("exit"),
                readline.PcItem("quit"),
        )

        rl, err := readline.NewEx(&amp;readline.Config{
                Prompt:          ui.Info("gokanon&gt; "),
                HistoryFile:     "/tmp/gokanon_history.tmp",
                AutoComplete:    completer,
                InterruptPrompt: "^C",
                EOFPrompt:       "exit",
        })

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov7" title="26">return &amp;Session{
                rl:       rl,
                commands: make(map[string]CommandHandler),
        }, nil</span>
}

// RegisterCommand registers a command handler
func (s *Session) RegisterCommand(name string, handler CommandHandler) <span class="cov10" title="119">{
        s.commands[name] = handler
}</span>

// Run starts the interactive session
func (s *Session) Run() error <span class="cov0" title="0">{
        defer s.rl.Close()

        s.printWelcome()

        for </span><span class="cov0" title="0">{
                line, err := s.rl.Readline()
                if err == readline.ErrInterrupt </span><span class="cov0" title="0">{
                        if len(line) == 0 </span><span class="cov0" title="0">{
                                break</span>
                        } else<span class="cov0" title="0"> {
                                continue</span>
                        }
                } else<span class="cov0" title="0"> if err == io.EOF </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">line = strings.TrimSpace(line)
                if line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Handle built-in commands
                <span class="cov0" title="0">if s.handleBuiltIn(line) </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Parse command and arguments
                <span class="cov0" title="0">parts := strings.Fields(line)
                if len(parts) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">command := parts[0]
                args := parts[1:]

                // Execute command
                handler, exists := s.commands[command]
                if !exists </span><span class="cov0" title="0">{
                        ui.PrintError("Unknown command: %s", command)
                        fmt.Println("Type 'help' for available commands")
                        continue</span>
                }

                <span class="cov0" title="0">if err := handler(args); err != nil </span><span class="cov0" title="0">{
                        ui.PrintError("Command failed: %v", err)
                }</span>
        }

        <span class="cov0" title="0">s.printGoodbye()
        return nil</span>
}

func (s *Session) printWelcome() <span class="cov1" title="1">{
        fmt.Println()
        fmt.Println(ui.Bold(""))
        fmt.Println(ui.Bold("") + "          " + ui.Info("Welcome to gokanon Interactive Mode!") + "          " + ui.Bold(""))
        fmt.Println(ui.Bold(""))
        fmt.Println()
        fmt.Println(ui.Dim("  Type 'help' for available commands"))
        fmt.Println(ui.Dim("  Use TAB for auto-completion"))
        fmt.Println(ui.Dim("  Press Ctrl+C or type 'exit' to quit"))
        fmt.Println()
}</span>

func (s *Session) printGoodbye() <span class="cov1" title="1">{
        fmt.Println()
        fmt.Printf("%s Thanks for using gokanon! Happy benchmarking! %s\n", ui.Success(ui.SuccessIcon), ui.RocketEmoji)
        fmt.Println()
}</span>

func (s *Session) handleBuiltIn(line string) bool <span class="cov8" title="47">{
        switch line </span>{
        case "exit", "quit":<span class="cov3" title="4">
                return true</span>
        case "clear", "cls":<span class="cov4" title="6">
                // Clear screen by printing ANSI escape code
                fmt.Print("\033[H\033[2J")
                return true</span>
        case "help", "?":<span class="cov4" title="7">
                s.printHelp()
                return true</span>
        default:<span class="cov7" title="30">
                return false</span>
        }
}

func (s *Session) printHelp() <span class="cov4" title="8">{
        fmt.Println()
        ui.PrintSection(ui.InfoIcon, "Available Commands")
        fmt.Println()

        commands := []struct {
                name        string
                description string
        }{
                {"run", "Run benchmarks and save results"},
                {"list", "List all saved benchmark results"},
                {"compare", "Compare two benchmark results"},
                {"export", "Export comparison results to various formats"},
                {"stats", "Show statistical analysis of multiple runs"},
                {"trend", "Analyze performance trends over time"},
                {"check", "Check performance against thresholds"},
                {"flamegraph", "View CPU/memory flame graphs"},
                {"serve", "Start interactive web dashboard"},
                {"delete", "Delete a benchmark result"},
                {"doctor", "Run diagnostics"},
                {"help", "Show this help message"},
                {"clear", "Clear the screen"},
                {"exit", "Exit interactive mode"},
        }

        for _, cmd := range commands </span><span class="cov9" title="112">{
                fmt.Printf("  %s %-12s %s\n",
                        ui.Info(ui.ArrowIcon),
                        ui.Bold(cmd.name),
                        ui.Dim(cmd.description))
        }</span>

        <span class="cov4" title="8">fmt.Println()
        fmt.Println(ui.Dim("For command-specific options, use: &lt;command&gt; -h"))
        fmt.Println()</span>
}

// Close closes the interactive session
func (s *Session) Close() error <span class="cov7" title="30">{
        return s.rl.Close()
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package profiler

import (
        "bytes"
        "fmt"
        "runtime/pprof"
        "sort"
        "strings"

        "github.com/alenon/gokanon/internal/models"
        "github.com/google/pprof/profile"
)

// Analyzer analyzes pprof profiles
type Analyzer struct {
        cpuProfile    *profile.Profile
        memoryProfile *profile.Profile
}

// NewAnalyzer creates a new profile analyzer
func NewAnalyzer() *Analyzer <span class="cov6" title="10">{
        return &amp;Analyzer{}
}</span>

// LoadCPUProfile loads a CPU profile from data
func (a *Analyzer) LoadCPUProfile(data []byte) error <span class="cov5" title="5">{
        prof, err := profile.Parse(bytes.NewReader(data))
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to parse CPU profile: %w", err)
        }</span>
        <span class="cov4" title="4">a.cpuProfile = prof
        return nil</span>
}

// LoadMemoryProfile loads a memory profile from data
func (a *Analyzer) LoadMemoryProfile(data []byte) error <span class="cov5" title="5">{
        prof, err := profile.Parse(bytes.NewReader(data))
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to parse memory profile: %w", err)
        }</span>
        <span class="cov4" title="4">a.memoryProfile = prof
        return nil</span>
}

// Analyze generates a complete profile summary
func (a *Analyzer) Analyze() (*models.ProfileSummary, error) <span class="cov6" title="7">{
        summary := &amp;models.ProfileSummary{}

        // Analyze CPU profile if available
        if a.cpuProfile != nil </span><span class="cov4" title="4">{
                cpuFuncs, totalSamples, err := a.analyzeCPUProfile()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to analyze CPU profile: %w", err)
                }</span>
                <span class="cov4" title="4">summary.CPUTopFunctions = cpuFuncs
                summary.TotalCPUSamples = totalSamples

                // Identify hot paths from CPU profile
                hotPaths := a.identifyHotPaths()
                summary.HotPaths = hotPaths</span>
        }

        // Analyze memory profile if available
        <span class="cov6" title="7">if a.memoryProfile != nil </span><span class="cov4" title="4">{
                memFuncs, totalBytes, err := a.analyzeMemoryProfile()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to analyze memory profile: %w", err)
                }</span>
                <span class="cov4" title="4">summary.MemoryTopFunctions = memFuncs
                summary.TotalMemoryBytes = totalBytes

                // Detect potential memory leaks
                leaks := a.detectMemoryLeaks()
                summary.MemoryLeaks = leaks</span>
        }

        // Generate optimization suggestions
        <span class="cov6" title="7">suggestions := a.generateSuggestions(summary)
        summary.Suggestions = suggestions

        return summary, nil</span>
}

// analyzeCPUProfile extracts top CPU-consuming functions
func (a *Analyzer) analyzeCPUProfile() ([]models.FunctionProfile, int64, error) <span class="cov4" title="4">{
        if a.cpuProfile == nil </span><span class="cov0" title="0">{
                return nil, 0, nil
        }</span>

        // Get total samples
        <span class="cov4" title="4">var totalSamples int64
        for _, sample := range a.cpuProfile.Sample </span><span class="cov6" title="8">{
                totalSamples += sample.Value[0]
        }</span>

        <span class="cov4" title="4">if totalSamples == 0 </span><span class="cov0" title="0">{
                return nil, 0, nil
        }</span>

        // Aggregate by function
        <span class="cov4" title="4">funcStats := make(map[string]*funcStat)
        for _, sample := range a.cpuProfile.Sample </span><span class="cov6" title="8">{
                value := sample.Value[0]
                if len(sample.Location) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Get the leaf function (top of stack)
                <span class="cov6" title="8">loc := sample.Location[0]
                if len(loc.Line) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov6" title="8">fn := loc.Line[0].Function
                if fn == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov6" title="8">funcName := fn.Name
                if stat, exists := funcStats[funcName]; exists </span><span class="cov0" title="0">{
                        stat.flat += value
                        stat.cum += value
                }</span> else<span class="cov6" title="8"> {
                        funcStats[funcName] = &amp;funcStat{
                                name: funcName,
                                flat: value,
                                cum:  value,
                        }
                }</span>

                // Add to callers as well (cumulative)
                <span class="cov6" title="8">for i := 1; i &lt; len(sample.Location); i++ </span><span class="cov0" title="0">{
                        if len(sample.Location[i].Line) == 0 </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">callerFn := sample.Location[i].Line[0].Function
                        if callerFn == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">callerName := callerFn.Name
                        if stat, exists := funcStats[callerName]; exists </span><span class="cov0" title="0">{
                                stat.cum += value
                        }</span> else<span class="cov0" title="0"> {
                                funcStats[callerName] = &amp;funcStat{
                                        name: callerName,
                                        flat: 0,
                                        cum:  value,
                                }
                        }</span>
                }
        }

        // Convert to slice and sort by flat time
        <span class="cov4" title="4">var stats []*funcStat
        for _, stat := range funcStats </span><span class="cov6" title="8">{
                stats = append(stats, stat)
        }</span>
        <span class="cov4" title="4">sort.Slice(stats, func(i, j int) bool </span><span class="cov4" title="4">{
                return stats[i].flat &gt; stats[j].flat
        }</span>)

        // Take top 10
        <span class="cov4" title="4">topCount := 10
        if len(stats) &lt; topCount </span><span class="cov4" title="4">{
                topCount = len(stats)
        }</span>

        <span class="cov4" title="4">var result []models.FunctionProfile
        for i := 0; i &lt; topCount; i++ </span><span class="cov6" title="8">{
                stat := stats[i]
                result = append(result, models.FunctionProfile{
                        Name:        cleanFunctionName(stat.name),
                        FlatPercent: float64(stat.flat) / float64(totalSamples) * 100,
                        CumPercent:  float64(stat.cum) / float64(totalSamples) * 100,
                        FlatValue:   stat.flat,
                        CumValue:    stat.cum,
                })
        }</span>

        <span class="cov4" title="4">return result, totalSamples, nil</span>
}

// analyzeMemoryProfile extracts top memory-allocating functions
func (a *Analyzer) analyzeMemoryProfile() ([]models.FunctionProfile, int64, error) <span class="cov4" title="4">{
        if a.memoryProfile == nil </span><span class="cov0" title="0">{
                return nil, 0, nil
        }</span>

        // Find the alloc_space index (bytes allocated)
        <span class="cov4" title="4">allocSpaceIdx := -1
        for i, st := range a.memoryProfile.SampleType </span><span class="cov6" title="8">{
                if st.Type == "alloc_space" </span><span class="cov4" title="4">{
                        allocSpaceIdx = i
                        break</span>
                }
        }

        <span class="cov4" title="4">if allocSpaceIdx == -1 </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("alloc_space not found in memory profile")
        }</span>

        // Get total bytes
        <span class="cov4" title="4">var totalBytes int64
        for _, sample := range a.memoryProfile.Sample </span><span class="cov6" title="7">{
                totalBytes += sample.Value[allocSpaceIdx]
        }</span>

        <span class="cov4" title="4">if totalBytes == 0 </span><span class="cov0" title="0">{
                return nil, 0, nil
        }</span>

        // Aggregate by function
        <span class="cov4" title="4">funcStats := make(map[string]*funcStat)
        for _, sample := range a.memoryProfile.Sample </span><span class="cov6" title="7">{
                value := sample.Value[allocSpaceIdx]
                if len(sample.Location) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Get the leaf function
                <span class="cov6" title="7">loc := sample.Location[0]
                if len(loc.Line) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov6" title="7">fn := loc.Line[0].Function
                if fn == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov6" title="7">funcName := fn.Name
                if stat, exists := funcStats[funcName]; exists </span><span class="cov0" title="0">{
                        stat.flat += value
                        stat.cum += value
                }</span> else<span class="cov6" title="7"> {
                        funcStats[funcName] = &amp;funcStat{
                                name: funcName,
                                flat: value,
                                cum:  value,
                        }
                }</span>
        }

        // Convert to slice and sort
        <span class="cov4" title="4">var stats []*funcStat
        for _, stat := range funcStats </span><span class="cov6" title="7">{
                stats = append(stats, stat)
        }</span>
        <span class="cov4" title="4">sort.Slice(stats, func(i, j int) bool </span><span class="cov3" title="3">{
                return stats[i].flat &gt; stats[j].flat
        }</span>)

        // Take top 10
        <span class="cov4" title="4">topCount := 10
        if len(stats) &lt; topCount </span><span class="cov4" title="4">{
                topCount = len(stats)
        }</span>

        <span class="cov4" title="4">var result []models.FunctionProfile
        for i := 0; i &lt; topCount; i++ </span><span class="cov6" title="7">{
                stat := stats[i]
                result = append(result, models.FunctionProfile{
                        Name:        cleanFunctionName(stat.name),
                        FlatPercent: float64(stat.flat) / float64(totalBytes) * 100,
                        CumPercent:  float64(stat.cum) / float64(totalBytes) * 100,
                        FlatValue:   stat.flat,
                        CumValue:    stat.cum,
                })
        }</span>

        <span class="cov4" title="4">return result, totalBytes, nil</span>
}

// identifyHotPaths identifies critical execution paths from CPU profile
func (a *Analyzer) identifyHotPaths() []models.HotPath <span class="cov4" title="4">{
        if a.cpuProfile == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Track call stacks and their frequencies
        <span class="cov4" title="4">pathCounts := make(map[string]*pathStat)

        var totalSamples int64
        for _, sample := range a.cpuProfile.Sample </span><span class="cov6" title="8">{
                value := sample.Value[0]
                totalSamples += value

                // Build call stack path
                var path []string
                for i := len(sample.Location) - 1; i &gt;= 0; i-- </span><span class="cov6" title="8">{
                        if len(sample.Location[i].Line) == 0 </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov6" title="8">fn := sample.Location[i].Line[0].Function
                        if fn != nil </span><span class="cov6" title="8">{
                                path = append(path, cleanFunctionName(fn.Name))
                        }</span>
                }

                <span class="cov6" title="8">if len(path) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov6" title="8">pathKey := strings.Join(path, " -&gt; ")
                if stat, exists := pathCounts[pathKey]; exists </span><span class="cov0" title="0">{
                        stat.count += value
                }</span> else<span class="cov6" title="8"> {
                        pathCounts[pathKey] = &amp;pathStat{
                                path:  path,
                                count: value,
                        }
                }</span>
        }

        // Convert to slice and sort
        <span class="cov4" title="4">var paths []*pathStat
        for _, stat := range pathCounts </span><span class="cov6" title="8">{
                paths = append(paths, stat)
        }</span>
        <span class="cov4" title="4">sort.Slice(paths, func(i, j int) bool </span><span class="cov4" title="4">{
                return paths[i].count &gt; paths[j].count
        }</span>)

        // Take top 5 paths that consume &gt; 5% of time
        <span class="cov4" title="4">var result []models.HotPath
        for _, p := range paths </span><span class="cov6" title="8">{
                percentage := float64(p.count) / float64(totalSamples) * 100
                if percentage &lt; 5.0 </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov6" title="8">if len(result) &gt;= 5 </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov6" title="8">result = append(result, models.HotPath{
                        Path:        p.path,
                        Percentage:  percentage,
                        Occurrences: p.count,
                        Description: fmt.Sprintf("Critical path consuming %.1f%% of execution time", percentage),
                })</span>
        }

        <span class="cov4" title="4">return result</span>
}

// detectMemoryLeaks identifies potential memory leak patterns
func (a *Analyzer) detectMemoryLeaks() []models.MemoryLeak <span class="cov4" title="4">{
        if a.memoryProfile == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Find alloc_space and inuse_space indices
        <span class="cov4" title="4">allocSpaceIdx := -1
        inuseSpaceIdx := -1
        for i, st := range a.memoryProfile.SampleType </span><span class="cov8" title="16">{
                if st.Type == "alloc_space" </span><span class="cov4" title="4">{
                        allocSpaceIdx = i
                }</span>
                <span class="cov8" title="16">if st.Type == "inuse_space" </span><span class="cov4" title="4">{
                        inuseSpaceIdx = i
                }</span>
        }

        <span class="cov4" title="4">if allocSpaceIdx == -1 || inuseSpaceIdx == -1 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Look for functions with high allocations
        <span class="cov4" title="4">funcLeaks := make(map[string]*leakStat)

        for _, sample := range a.memoryProfile.Sample </span><span class="cov6" title="7">{
                allocated := sample.Value[allocSpaceIdx]
                inuse := sample.Value[inuseSpaceIdx]

                if len(sample.Location) == 0 || allocated == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov6" title="7">loc := sample.Location[0]
                if len(loc.Line) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov6" title="7">fn := loc.Line[0].Function
                if fn == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov6" title="7">funcName := fn.Name
                if stat, exists := funcLeaks[funcName]; exists </span><span class="cov0" title="0">{
                        stat.allocated += allocated
                        stat.inuse += inuse
                        stat.count++
                }</span> else<span class="cov6" title="7"> {
                        funcLeaks[funcName] = &amp;leakStat{
                                name:      funcName,
                                allocated: allocated,
                                inuse:     inuse,
                                count:     1,
                        }
                }</span>
        }

        <span class="cov4" title="4">var result []models.MemoryLeak
        for _, stat := range funcLeaks </span><span class="cov6" title="7">{
                // If a function allocated much more than it's using, it might be leaking
                if stat.allocated &gt; stat.inuse*2 &amp;&amp; stat.allocated &gt; 1024*1024 </span><span class="cov4" title="4">{ // &gt; 1MB
                        severity := "low"
                        if stat.allocated &gt; 10*1024*1024 </span><span class="cov0" title="0">{
                                severity = "high"
                        }</span> else<span class="cov4" title="4"> if stat.allocated &gt; 5*1024*1024 </span><span class="cov1" title="1">{
                                severity = "medium"
                        }</span>

                        <span class="cov4" title="4">result = append(result, models.MemoryLeak{
                                Function:    cleanFunctionName(stat.name),
                                Allocations: stat.count,
                                Bytes:       stat.allocated,
                                Severity:    severity,
                                Description: fmt.Sprintf("Allocated %s but much less in use - potential leak", formatBytes(stat.allocated)),
                        })</span>
                }
        }

        // Sort by severity and bytes
        <span class="cov4" title="4">sort.Slice(result, func(i, j int) bool </span><span class="cov0" title="0">{
                if result[i].Severity != result[j].Severity </span><span class="cov0" title="0">{
                        severityOrder := map[string]int{"high": 3, "medium": 2, "low": 1}
                        return severityOrder[result[i].Severity] &gt; severityOrder[result[j].Severity]
                }</span>
                <span class="cov0" title="0">return result[i].Bytes &gt; result[j].Bytes</span>
        })

        // Limit to top 5
        <span class="cov4" title="4">if len(result) &gt; 5 </span><span class="cov0" title="0">{
                result = result[:5]
        }</span>

        <span class="cov4" title="4">return result</span>
}

// generateSuggestions generates optimization suggestions based on profile data
func (a *Analyzer) generateSuggestions(summary *models.ProfileSummary) []models.Suggestion <span class="cov6" title="7">{
        var suggestions []models.Suggestion

        // CPU suggestions
        if len(summary.CPUTopFunctions) &gt; 0 </span><span class="cov4" title="4">{
                top := summary.CPUTopFunctions[0]
                if top.FlatPercent &gt; 30 </span><span class="cov4" title="4">{
                        suggestions = append(suggestions, models.Suggestion{
                                Type:       "cpu",
                                Severity:   "high",
                                Function:   top.Name,
                                Issue:      fmt.Sprintf("Function consumes %.1f%% of CPU time", top.FlatPercent),
                                Suggestion: "Consider optimizing this hot function - profile it in isolation, look for unnecessary allocations, consider algorithmic improvements",
                                Impact:     fmt.Sprintf("Could improve overall performance by up to %.0f%%", top.FlatPercent*0.7),
                        })
                }</span>
        }

        // Memory suggestions
        <span class="cov6" title="7">if len(summary.MemoryTopFunctions) &gt; 0 </span><span class="cov4" title="4">{
                top := summary.MemoryTopFunctions[0]
                if top.FlatPercent &gt; 40 </span><span class="cov4" title="4">{
                        suggestions = append(suggestions, models.Suggestion{
                                Type:       "memory",
                                Severity:   "high",
                                Function:   top.Name,
                                Issue:      fmt.Sprintf("Function allocates %.1f%% of total memory", top.FlatPercent),
                                Suggestion: "Consider using sync.Pool for reusable objects, or pre-allocate slices/maps with appropriate capacity",
                                Impact:     "Could significantly reduce allocation pressure and GC overhead",
                        })
                }</span>
        }

        // Memory leak suggestions
        <span class="cov6" title="7">for _, leak := range summary.MemoryLeaks </span><span class="cov4" title="4">{
                if leak.Severity == "high" </span><span class="cov0" title="0">{
                        suggestions = append(suggestions, models.Suggestion{
                                Type:       "memory",
                                Severity:   "high",
                                Function:   leak.Function,
                                Issue:      "Potential memory leak detected",
                                Suggestion: "Review this function for retained references, unclosed resources, or unbounded caches",
                                Impact:     "Could prevent memory growth and improve stability",
                        })
                }</span>
        }

        // Hot path suggestions
        <span class="cov6" title="7">if len(summary.HotPaths) &gt; 0 </span><span class="cov4" title="4">{
                for _, path := range summary.HotPaths </span><span class="cov4" title="4">{
                        if path.Percentage &gt; 25 </span><span class="cov4" title="4">{
                                suggestions = append(suggestions, models.Suggestion{
                                        Type:       "cpu",
                                        Severity:   "medium",
                                        Function:   strings.Join(path.Path, " -&gt; "),
                                        Issue:      fmt.Sprintf("Hot path consuming %.1f%% of execution", path.Percentage),
                                        Suggestion: "Analyze this call chain for optimization opportunities - consider caching, lazy evaluation, or algorithmic improvements",
                                        Impact:     fmt.Sprintf("Optimizing this path could improve performance by %.0f-%.0f%%", path.Percentage*0.5, path.Percentage*0.8),
                                })
                                break</span> // Only suggest one hot path
                        }
                }
        }

        <span class="cov6" title="7">return suggestions</span>
}

// Helper types
type funcStat struct {
        name string
        flat int64
        cum  int64
}

type pathStat struct {
        path  []string
        count int64
}

type leakStat struct {
        name      string
        allocated int64
        inuse     int64
        count     int64
}

// cleanFunctionName removes package paths and simplifies function names
func cleanFunctionName(name string) string <span class="cov10" title="32">{
        // Remove package path, keep only last part
        parts := strings.Split(name, "/")
        if len(parts) &gt; 0 </span><span class="cov10" title="32">{
                name = parts[len(parts)-1]
        }</span>

        // Remove type parameters
        <span class="cov10" title="32">if idx := strings.Index(name, "["); idx != -1 </span><span class="cov2" title="2">{
                name = name[:idx]
        }</span>

        <span class="cov10" title="32">return name</span>
}

// formatBytes formats bytes in human-readable format
func formatBytes(bytes int64) string <span class="cov6" title="10">{
        const unit = 1024
        if bytes &lt; unit </span><span class="cov2" title="2">{
                return fmt.Sprintf("%d B", bytes)
        }</span>
        <span class="cov6" title="8">div, exp := int64(unit), 0
        for n := bytes / unit; n &gt;= unit; n /= unit </span><span class="cov6" title="8">{
                div *= unit
                exp++
        }</span>
        <span class="cov6" title="8">return fmt.Sprintf("%.1f %cB", float64(bytes)/float64(div), "KMGTPE"[exp])</span>
}

// GetProfileTypes returns available profile types from pprof
func GetProfileTypes() []string <span class="cov1" title="1">{
        var types []string
        for _, p := range pprof.Profiles() </span><span class="cov5" title="6">{
                types = append(types, p.Name())
        }</span>
        <span class="cov1" title="1">return types</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package runner

import (
        "bufio"
        "bytes"
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "regexp"
        "strconv"
        "strings"
        "time"

        "github.com/alenon/gokanon/internal/aianalyzer"
        "github.com/alenon/gokanon/internal/models"
        "github.com/alenon/gokanon/internal/profiler"
        "github.com/alenon/gokanon/internal/storage"
)

// ProfileOptions configures profiling behavior
type ProfileOptions struct {
        EnableCPU    bool
        EnableMemory bool
        Storage      *storage.Storage
}

// Runner handles benchmark execution
type Runner struct {
        packagePath    string
        benchFilter    string
        profileOptions *ProfileOptions
}

// NewRunner creates a new benchmark runner
func NewRunner(packagePath, benchFilter string) *Runner <span class="cov6" title="10">{
        return &amp;Runner{
                packagePath: packagePath,
                benchFilter: benchFilter,
        }
}</span>

// WithProfiling configures the runner to enable profiling
func (r *Runner) WithProfiling(opts *ProfileOptions) *Runner <span class="cov2" title="2">{
        r.profileOptions = opts
        return r
}</span>

// Run executes the benchmarks and returns parsed results
func (r *Runner) Run() (*models.BenchmarkRun, error) <span class="cov4" title="4">{
        startTime := time.Now()

        // Get Go version
        goVersion, err := r.getGoVersion()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get Go version: %w", err)
        }</span>

        // Generate unique ID for this run
        <span class="cov4" title="4">runID := generateID()

        // Create temporary directory for profile files
        tempDir, err := os.MkdirTemp("", "gokanon-profile-*")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create temp directory: %w", err)
        }</span>
        <span class="cov4" title="4">defer os.RemoveAll(tempDir)

        // Build the benchmark command
        args := []string{"test", "-bench", r.benchFilter, "-benchmem"}

        // Add profiling flags if enabled
        var cpuProfilePath, memProfilePath string
        if r.profileOptions != nil </span><span class="cov1" title="1">{
                if r.profileOptions.EnableCPU </span><span class="cov1" title="1">{
                        cpuProfilePath = filepath.Join(tempDir, "cpu.prof")
                        args = append(args, "-cpuprofile", cpuProfilePath)
                }</span>
                <span class="cov1" title="1">if r.profileOptions.EnableMemory </span><span class="cov1" title="1">{
                        memProfilePath = filepath.Join(tempDir, "mem.prof")
                        args = append(args, "-memprofile", memProfilePath)
                }</span>
        }

        <span class="cov4" title="4">if r.packagePath != "" </span><span class="cov4" title="4">{
                args = append(args, r.packagePath)
        }</span> else<span class="cov0" title="0"> {
                args = append(args, "./...")
        }</span>

        // Execute benchmark
        <span class="cov4" title="4">cmd := exec.Command("go", args...)
        var stdout, stderr bytes.Buffer
        cmd.Stdout = &amp;stdout
        cmd.Stderr = &amp;stderr

        if err := cmd.Run(); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("benchmark execution failed: %w\nStderr: %s", err, stderr.String())
        }</span>

        // Parse results
        <span class="cov3" title="3">results, err := r.parseOutput(stdout.String())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse benchmark output: %w", err)
        }</span>

        <span class="cov3" title="3">duration := time.Since(startTime)

        run := &amp;models.BenchmarkRun{
                ID:        runID,
                Timestamp: startTime,
                Package:   r.packagePath,
                GoVersion: goVersion,
                Results:   results,
                Command:   fmt.Sprintf("go %s", strings.Join(args, " ")),
                Duration:  duration,
        }

        // Handle profile files if profiling was enabled
        if r.profileOptions != nil &amp;&amp; r.profileOptions.Storage != nil </span><span class="cov1" title="1">{
                if err := r.handleProfiles(run, cpuProfilePath, memProfilePath); err != nil </span><span class="cov0" title="0">{
                        // Log warning but don't fail the run
                        fmt.Fprintf(os.Stderr, "Warning: failed to process profiles: %v\n", err)
                }</span>
        }

        <span class="cov3" title="3">return run, nil</span>
}

// parseOutput parses the benchmark output from go test -bench
func (r *Runner) parseOutput(output string) ([]models.BenchmarkResult, error) <span class="cov6" title="10">{
        var results []models.BenchmarkResult

        // Regex to match benchmark lines
        // Example: BenchmarkFoo-8   1000000   1234 ns/op   512 B/op   10 allocs/op
        benchRegex := regexp.MustCompile(`^Benchmark(\S+)\s+(\d+)\s+([\d.]+)\s+ns/op(?:\s+([\d.]+)\s+MB/s)?(?:\s+(\d+)\s+B/op)?(?:\s+(\d+)\s+allocs/op)?`)

        scanner := bufio.NewScanner(strings.NewReader(output))
        // Increase buffer size to handle long output lines (default is 64KB, set to 1MB)
        buf := make([]byte, 0, 64*1024)
        scanner.Buffer(buf, 1024*1024) // 1MB max token size
        for scanner.Scan() </span><span class="cov10" title="59">{
                line := scanner.Text()
                matches := benchRegex.FindStringSubmatch(line)

                if matches != nil </span><span class="cov8" title="32">{
                        name := matches[1]
                        iterations, _ := strconv.ParseInt(matches[2], 10, 64)
                        nsPerOp, _ := strconv.ParseFloat(matches[3], 64)

                        result := models.BenchmarkResult{
                                Name:       name,
                                Iterations: iterations,
                                NsPerOp:    nsPerOp,
                        }

                        // Parse optional MB/s
                        if matches[4] != "" </span><span class="cov2" title="2">{
                                result.MBPerSec, _ = strconv.ParseFloat(matches[4], 64)
                        }</span>

                        // Parse optional B/op
                        <span class="cov8" title="32">if matches[5] != "" </span><span class="cov8" title="31">{
                                result.BytesPerOp, _ = strconv.ParseInt(matches[5], 10, 64)
                        }</span>

                        // Parse optional allocs/op
                        <span class="cov8" title="32">if matches[6] != "" </span><span class="cov8" title="31">{
                                result.AllocsPerOp, _ = strconv.ParseInt(matches[6], 10, 64)
                        }</span>

                        <span class="cov8" title="32">results = append(results, result)</span>
                }
        }

        <span class="cov6" title="10">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov6" title="10">if len(results) == 0 </span><span class="cov2" title="2">{
                return nil, fmt.Errorf("no benchmark results found in output")
        }</span>

        <span class="cov5" title="8">return results, nil</span>
}

// getGoVersion returns the current Go version
func (r *Runner) getGoVersion() (string, error) <span class="cov4" title="5">{
        cmd := exec.Command("go", "version")
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov4" title="5">return strings.TrimSpace(string(output)), nil</span>
}

// generateID generates a unique ID for a benchmark run
func generateID() string <span class="cov4" title="5">{
        return fmt.Sprintf("run-%d", time.Now().Unix())
}</span>

// handleProfiles processes and stores profile files, and analyzes them
func (r *Runner) handleProfiles(run *models.BenchmarkRun, cpuProfilePath, memProfilePath string) error <span class="cov1" title="1">{
        store := r.profileOptions.Storage
        analyzer := profiler.NewAnalyzer()

        // Process CPU profile
        if cpuProfilePath != "" </span><span class="cov1" title="1">{
                if _, err := os.Stat(cpuProfilePath); err == nil </span><span class="cov1" title="1">{
                        // Read profile data
                        cpuData, err := os.ReadFile(cpuProfilePath)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to read CPU profile: %w", err)
                        }</span>

                        // Save to storage
                        <span class="cov1" title="1">if err := store.SaveProfile(run.ID, "cpu", bytes.NewReader(cpuData)); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to save CPU profile: %w", err)
                        }</span>

                        // Set profile path in run
                        <span class="cov1" title="1">run.CPUProfile = store.GetCPUProfilePath(run.ID)

                        // Load into analyzer
                        if err := analyzer.LoadCPUProfile(cpuData); err != nil </span><span class="cov0" title="0">{
                                fmt.Fprintf(os.Stderr, "Warning: failed to analyze CPU profile: %v\n", err)
                        }</span>
                }
        }

        // Process memory profile
        <span class="cov1" title="1">if memProfilePath != "" </span><span class="cov1" title="1">{
                if _, err := os.Stat(memProfilePath); err == nil </span><span class="cov1" title="1">{
                        // Read profile data
                        memData, err := os.ReadFile(memProfilePath)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to read memory profile: %w", err)
                        }</span>

                        // Save to storage
                        <span class="cov1" title="1">if err := store.SaveProfile(run.ID, "memory", bytes.NewReader(memData)); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to save memory profile: %w", err)
                        }</span>

                        // Set profile path in run
                        <span class="cov1" title="1">run.MemoryProfile = store.GetMemoryProfilePath(run.ID)

                        // Load into analyzer
                        if err := analyzer.LoadMemoryProfile(memData); err != nil </span><span class="cov0" title="0">{
                                fmt.Fprintf(os.Stderr, "Warning: failed to analyze memory profile: %v\n", err)
                        }</span>
                }
        }

        // Analyze profiles and generate summary
        <span class="cov1" title="1">if run.CPUProfile != "" || run.MemoryProfile != "" </span><span class="cov1" title="1">{
                summary, err := analyzer.Analyze()
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Warning: failed to analyze profiles: %v\n", err)
                }</span> else<span class="cov1" title="1"> {
                        // Enhance with AI analysis if enabled
                        aiAnalyzer, err := aianalyzer.NewFromEnv()
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Fprintf(os.Stderr, "Warning: failed to initialize AI analyzer: %v\n", err)
                                run.ProfileSummary = summary
                        }</span> else<span class="cov1" title="1"> {
                                enhanced, err := aiAnalyzer.EnhanceProfileSummary(summary)
                                if err != nil </span><span class="cov0" title="0">{
                                        fmt.Fprintf(os.Stderr, "Warning: AI analysis failed: %v\n", err)
                                        run.ProfileSummary = summary
                                }</span> else<span class="cov1" title="1"> {
                                        run.ProfileSummary = enhanced
                                }</span>
                        }
                }
        }

        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package stats

import (
        "fmt"
        "math"
        "sort"

        "github.com/alenon/gokanon/internal/models"
)

// Stats represents statistical data for a benchmark across multiple runs
type Stats struct {
        Name     string
        Count    int
        Mean     float64
        Median   float64
        Min      float64
        Max      float64
        StdDev   float64
        Variance float64
        CV       float64 // Coefficient of Variation (StdDev/Mean)
}

// Analyzer handles statistical analysis of benchmarks
type Analyzer struct{}

// NewAnalyzer creates a new analyzer
func NewAnalyzer() *Analyzer <span class="cov7" title="11">{
        return &amp;Analyzer{}
}</span>

// AnalyzeMultiple analyzes multiple benchmark runs and provides statistics
func (a *Analyzer) AnalyzeMultiple(runs []models.BenchmarkRun) map[string]*Stats <span class="cov1" title="1">{
        // Group results by benchmark name
        grouped := make(map[string][]float64)

        for _, run := range runs </span><span class="cov3" title="3">{
                for _, result := range run.Results </span><span class="cov5" title="6">{
                        grouped[result.Name] = append(grouped[result.Name], result.NsPerOp)
                }</span>
        }

        // Calculate statistics for each benchmark
        <span class="cov1" title="1">stats := make(map[string]*Stats)
        for name, values := range grouped </span><span class="cov2" title="2">{
                stats[name] = a.calculateStats(name, values)
        }</span>

        <span class="cov1" title="1">return stats</span>
}

// calculateStats calculates statistical measures for a set of values
func (a *Analyzer) calculateStats(name string, values []float64) *Stats <span class="cov6" title="9">{
        if len(values) == 0 </span><span class="cov1" title="1">{
                return nil
        }</span>

        // Sort values for median calculation
        <span class="cov6" title="8">sorted := make([]float64, len(values))
        copy(sorted, values)
        sort.Float64s(sorted)

        stats := &amp;Stats{
                Name:  name,
                Count: len(values),
                Min:   sorted[0],
                Max:   sorted[len(sorted)-1],
        }

        // Calculate mean
        sum := 0.0
        for _, v := range values </span><span class="cov10" title="31">{
                sum += v
        }</span>
        <span class="cov6" title="8">stats.Mean = sum / float64(len(values))

        // Calculate median
        if len(sorted)%2 == 0 </span><span class="cov3" title="3">{
                stats.Median = (sorted[len(sorted)/2-1] + sorted[len(sorted)/2]) / 2
        }</span> else<span class="cov5" title="5"> {
                stats.Median = sorted[len(sorted)/2]
        }</span>

        // Calculate variance and standard deviation
        <span class="cov6" title="8">sumSquaredDiff := 0.0
        for _, v := range values </span><span class="cov10" title="31">{
                diff := v - stats.Mean
                sumSquaredDiff += diff * diff
        }</span>
        <span class="cov6" title="8">stats.Variance = sumSquaredDiff / float64(len(values))
        stats.StdDev = math.Sqrt(stats.Variance)

        // Calculate coefficient of variation
        if stats.Mean != 0 </span><span class="cov6" title="8">{
                stats.CV = (stats.StdDev / stats.Mean) * 100
        }</span>

        <span class="cov6" title="8">return stats</span>
}

// FormatStats formats statistics for display
func FormatStats(stats *Stats) string <span class="cov1" title="1">{
        return fmt.Sprintf(
                "%-40s Count: %3d | Mean: %10.2f ns/op | Median: %10.2f ns/op | StdDev: %8.2f (%.1f%%) | Range: [%.2f - %.2f]",
                stats.Name,
                stats.Count,
                stats.Mean,
                stats.Median,
                stats.StdDev,
                stats.CV,
                stats.Min,
                stats.Max,
        )
}</span>

// IsStable returns true if the benchmark is considered stable (low variation)
func (s *Stats) IsStable(threshold float64) bool <span class="cov5" title="5">{
        return s.CV &lt;= threshold
}</span>

// TrendAnalysis represents performance trend over time
type TrendAnalysis struct {
        BenchmarkName string
        Direction     string  // "improving", "degrading", "stable"
        TrendLine     float64 // Slope of the trend line
        Confidence    float64 // R-squared value (0-1)
}

// AnalyzeTrend analyzes the performance trend over time
func (a *Analyzer) AnalyzeTrend(runs []models.BenchmarkRun, benchmarkName string) *TrendAnalysis <span class="cov5" title="5">{
        var values []float64
        var times []float64

        for i, run := range runs </span><span class="cov8" title="15">{
                for _, result := range run.Results </span><span class="cov8" title="15">{
                        if result.Name == benchmarkName </span><span class="cov7" title="13">{
                                values = append(values, result.NsPerOp)
                                times = append(times, float64(i))
                                break</span>
                        }
                }
        }

        <span class="cov5" title="5">if len(values) &lt; 2 </span><span class="cov2" title="2">{
                return nil
        }</span>

        // Calculate linear regression
        <span class="cov3" title="3">slope, _, rSquared := linearRegression(times, values)

        direction := "stable"
        if math.Abs(slope) &gt; 1.0 </span><span class="cov2" title="2">{ // Threshold for meaningful change
                if slope &lt; 0 </span><span class="cov1" title="1">{
                        direction = "improving"
                }</span> else<span class="cov1" title="1"> {
                        direction = "degrading"
                }</span>
        }

        <span class="cov3" title="3">return &amp;TrendAnalysis{
                BenchmarkName: benchmarkName,
                Direction:     direction,
                TrendLine:     slope,
                Confidence:    rSquared,
        }</span>
}

// linearRegression calculates the linear regression for the given data
// Returns: slope, intercept, r-squared
func linearRegression(x, y []float64) (float64, float64, float64) <span class="cov5" title="5">{
        n := float64(len(x))

        var sumX, sumY, sumXY, sumX2, sumY2 float64
        for i := 0; i &lt; len(x); i++ </span><span class="cov9" title="22">{
                sumX += x[i]
                sumY += y[i]
                sumXY += x[i] * y[i]
                sumX2 += x[i] * x[i]
                sumY2 += y[i] * y[i]
        }</span>

        // Calculate slope and intercept
        <span class="cov5" title="5">slope := (n*sumXY - sumX*sumY) / (n*sumX2 - sumX*sumX)
        intercept := (sumY - slope*sumX) / n

        // Calculate R-squared
        meanY := sumY / n
        ssRes := 0.0 // Sum of squares of residuals
        ssTot := 0.0 // Total sum of squares

        for i := 0; i &lt; len(x); i++ </span><span class="cov9" title="22">{
                predicted := slope*x[i] + intercept
                ssRes += (y[i] - predicted) * (y[i] - predicted)
                ssTot += (y[i] - meanY) * (y[i] - meanY)
        }</span>

        <span class="cov5" title="5">rSquared := 1.0
        if ssTot != 0 </span><span class="cov5" title="5">{
                rSquared = 1.0 - (ssRes / ssTot)
        }</span>

        <span class="cov5" title="5">return slope, intercept, rSquared</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package storage

import (
        "encoding/json"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "sort"
        "time"

        "github.com/alenon/gokanon/internal/models"
)

const (
        defaultDir = ".gokanon"
)

// Storage handles saving and loading benchmark results
type Storage struct {
        dir string
}

// NewStorage creates a new storage instance
func NewStorage(dir string) *Storage <span class="cov10" title="28">{
        if dir == "" </span><span class="cov1" title="1">{
                dir = defaultDir
        }</span>
        <span class="cov10" title="28">return &amp;Storage{dir: dir}</span>
}

// Save saves a benchmark run to storage
func (s *Storage) Save(run *models.BenchmarkRun) error <span class="cov8" title="16">{
        // Ensure directory exists
        if err := os.MkdirAll(s.dir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create storage directory: %w", err)
        }</span>

        // Create filename based on ID
        <span class="cov8" title="16">filename := filepath.Join(s.dir, run.ID+".json")

        // Marshal to JSON
        data, err := json.MarshalIndent(run, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal benchmark run: %w", err)
        }</span>

        // Write to file
        <span class="cov8" title="16">if err := os.WriteFile(filename, data, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write benchmark run: %w", err)
        }</span>

        <span class="cov8" title="16">return nil</span>
}

// Load loads a benchmark run from storage by ID
func (s *Storage) Load(id string) (*models.BenchmarkRun, error) <span class="cov8" title="18">{
        filename := filepath.Join(s.dir, id+".json")

        data, err := os.ReadFile(filename)
        if err != nil </span><span class="cov2" title="2">{
                return nil, fmt.Errorf("failed to read benchmark run: %w", err)
        }</span>

        <span class="cov8" title="16">var run models.BenchmarkRun
        if err := json.Unmarshal(data, &amp;run); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to unmarshal benchmark run: %w", err)
        }</span>

        <span class="cov8" title="15">return &amp;run, nil</span>
}

// List returns all available benchmark run IDs, sorted by timestamp (newest first)
func (s *Storage) List() ([]models.BenchmarkRun, error) <span class="cov5" title="6">{
        // Check if directory exists
        if _, err := os.Stat(s.dir); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return []models.BenchmarkRun{}, nil
        }</span>

        <span class="cov5" title="6">entries, err := os.ReadDir(s.dir)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read storage directory: %w", err)
        }</span>

        <span class="cov5" title="6">var runs []models.BenchmarkRun
        for _, entry := range entries </span><span class="cov7" title="10">{
                if entry.IsDir() || filepath.Ext(entry.Name()) != ".json" </span><span class="cov2" title="2">{
                        continue</span>
                }

                <span class="cov6" title="8">id := entry.Name()[:len(entry.Name())-5] // Remove .json
                run, err := s.Load(id)
                if err != nil </span><span class="cov1" title="1">{
                        continue</span> // Skip invalid files
                }
                <span class="cov6" title="7">runs = append(runs, *run)</span>
        }

        // Sort by timestamp, newest first
        <span class="cov5" title="6">sort.Slice(runs, func(i, j int) bool </span><span class="cov5" title="5">{
                return runs[i].Timestamp.After(runs[j].Timestamp)
        }</span>)

        <span class="cov5" title="6">return runs, nil</span>
}

// Delete removes a benchmark run from storage, including profile files
func (s *Storage) Delete(id string) error <span class="cov3" title="3">{
        filename := filepath.Join(s.dir, id+".json")
        if err := os.Remove(filename); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to delete benchmark run: %w", err)
        }</span>

        // Also delete profile directory if it exists
        <span class="cov2" title="2">profileDir := s.GetProfileDir(id)
        if _, err := os.Stat(profileDir); err == nil </span><span class="cov1" title="1">{
                if err := os.RemoveAll(profileDir); err != nil </span><span class="cov0" title="0">{
                        // Log but don't fail if profile cleanup fails
                        fmt.Fprintf(os.Stderr, "Warning: failed to delete profile directory: %v\n", err)
                }</span>
        }

        <span class="cov2" title="2">return nil</span>
}

// GetLatest returns the most recent benchmark run
func (s *Storage) GetLatest() (*models.BenchmarkRun, error) <span class="cov3" title="3">{
        runs, err := s.List()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov3" title="3">if len(runs) == 0 </span><span class="cov2" title="2">{
                return nil, fmt.Errorf("no benchmark runs found")
        }</span>

        <span class="cov1" title="1">return &amp;runs[0], nil</span>
}

// GetProfileDir returns the profile directory for a given run ID
func (s *Storage) GetProfileDir(runID string) string <span class="cov9" title="26">{
        return filepath.Join(s.dir, "profiles", runID)
}</span>

// GetCPUProfilePath returns the path to the CPU profile for a run
func (s *Storage) GetCPUProfilePath(runID string) string <span class="cov7" title="10">{
        return filepath.Join(s.GetProfileDir(runID), "cpu.prof")
}</span>

// GetMemoryProfilePath returns the path to the memory profile for a run
func (s *Storage) GetMemoryProfilePath(runID string) string <span class="cov5" title="5">{
        return filepath.Join(s.GetProfileDir(runID), "mem.prof")
}</span>

// SaveProfile saves a profile file to the storage
func (s *Storage) SaveProfile(runID, profileType string, data io.Reader) error <span class="cov6" title="7">{
        profileDir := s.GetProfileDir(runID)

        // Create profile directory
        if err := os.MkdirAll(profileDir, 0755); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to create profile directory: %w", err)
        }</span>

        // Determine filename
        <span class="cov5" title="6">var filename string
        switch profileType </span>{
        case "cpu":<span class="cov3" title="3">
                filename = s.GetCPUProfilePath(runID)</span>
        case "memory", "mem":<span class="cov2" title="2">
                filename = s.GetMemoryProfilePath(runID)</span>
        default:<span class="cov1" title="1">
                return fmt.Errorf("unknown profile type: %s", profileType)</span>
        }

        // Create file
        <span class="cov5" title="5">out, err := os.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create profile file: %w", err)
        }</span>
        <span class="cov5" title="5">defer out.Close()

        // Copy data
        if _, err := io.Copy(out, data); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write profile data: %w", err)
        }</span>

        <span class="cov5" title="5">return nil</span>
}

// LoadProfile loads a profile file from storage
func (s *Storage) LoadProfile(runID, profileType string) ([]byte, error) <span class="cov5" title="5">{
        var filename string
        switch profileType </span>{
        case "cpu":<span class="cov2" title="2">
                filename = s.GetCPUProfilePath(runID)</span>
        case "memory", "mem":<span class="cov2" title="2">
                filename = s.GetMemoryProfilePath(runID)</span>
        default:<span class="cov1" title="1">
                return nil, fmt.Errorf("unknown profile type: %s", profileType)</span>
        }

        <span class="cov4" title="4">data, err := os.ReadFile(filename)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to read profile file: %w", err)
        }</span>

        <span class="cov3" title="3">return data, nil</span>
}

// HasProfile checks if a profile exists for a run
func (s *Storage) HasProfile(runID, profileType string) bool <span class="cov5" title="5">{
        var filename string
        switch profileType </span>{
        case "cpu":<span class="cov4" title="4">
                filename = s.GetCPUProfilePath(runID)</span>
        case "memory", "mem":<span class="cov0" title="0">
                filename = s.GetMemoryProfilePath(runID)</span>
        default:<span class="cov1" title="1">
                return false</span>
        }

        <span class="cov4" title="4">_, err := os.Stat(filename)
        return err == nil</span>
}

// GetBaselineDir returns the baselines directory
func (s *Storage) GetBaselineDir() string <span class="cov9" title="26">{
        return filepath.Join(s.dir, "baselines")
}</span>

// SaveBaseline saves a benchmark run as a baseline with the given name
func (s *Storage) SaveBaseline(name, runID, description string, tags map[string]string) (*models.Baseline, error) <span class="cov6" title="8">{
        // Load the run
        run, err := s.Load(runID)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to load run %s: %w", runID, err)
        }</span>

        // Create baseline
        <span class="cov6" title="7">baseline := &amp;models.Baseline{
                Name:        name,
                RunID:       runID,
                CreatedAt:   time.Now(),
                Description: description,
                Run:         run,
                Tags:        tags,
        }

        // Ensure baselines directory exists
        baselineDir := s.GetBaselineDir()
        if err := os.MkdirAll(baselineDir, 0755); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create baselines directory: %w", err)
        }</span>

        // Save baseline
        <span class="cov6" title="7">filename := filepath.Join(baselineDir, name+".json")
        data, err := json.MarshalIndent(baseline, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal baseline: %w", err)
        }</span>

        <span class="cov6" title="7">if err := os.WriteFile(filename, data, 0644); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to write baseline: %w", err)
        }</span>

        <span class="cov6" title="7">return baseline, nil</span>
}

// LoadBaseline loads a baseline by name
func (s *Storage) LoadBaseline(name string) (*models.Baseline, error) <span class="cov6" title="8">{
        filename := filepath.Join(s.GetBaselineDir(), name+".json")

        data, err := os.ReadFile(filename)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to read baseline %s: %w", name, err)
        }</span>

        <span class="cov6" title="7">var baseline models.Baseline
        if err := json.Unmarshal(data, &amp;baseline); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to unmarshal baseline: %w", err)
        }</span>

        <span class="cov5" title="6">return &amp;baseline, nil</span>
}

// ListBaselines returns all available baselines
func (s *Storage) ListBaselines() ([]models.Baseline, error) <span class="cov4" title="4">{
        baselineDir := s.GetBaselineDir()

        // Check if directory exists
        if _, err := os.Stat(baselineDir); os.IsNotExist(err) </span><span class="cov1" title="1">{
                return []models.Baseline{}, nil
        }</span>

        <span class="cov3" title="3">entries, err := os.ReadDir(baselineDir)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read baselines directory: %w", err)
        }</span>

        <span class="cov3" title="3">var baselines []models.Baseline
        for _, entry := range entries </span><span class="cov6" title="8">{
                if entry.IsDir() || filepath.Ext(entry.Name()) != ".json" </span><span class="cov2" title="2">{
                        continue</span>
                }

                <span class="cov5" title="6">name := entry.Name()[:len(entry.Name())-5] // Remove .json
                baseline, err := s.LoadBaseline(name)
                if err != nil </span><span class="cov1" title="1">{
                        continue</span> // Skip invalid files
                }
                <span class="cov5" title="5">baselines = append(baselines, *baseline)</span>
        }

        // Sort by creation time, newest first
        <span class="cov3" title="3">sort.Slice(baselines, func(i, j int) bool </span><span class="cov3" title="3">{
                return baselines[i].CreatedAt.After(baselines[j].CreatedAt)
        }</span>)

        <span class="cov3" title="3">return baselines, nil</span>
}

// DeleteBaseline removes a baseline from storage
func (s *Storage) DeleteBaseline(name string) error <span class="cov2" title="2">{
        filename := filepath.Join(s.GetBaselineDir(), name+".json")
        if err := os.Remove(filename); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to delete baseline %s: %w", name, err)
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// HasBaseline checks if a baseline with the given name exists
func (s *Storage) HasBaseline(name string) bool <span class="cov3" title="3">{
        filename := filepath.Join(s.GetBaselineDir(), name+".json")
        _, err := os.Stat(filename)
        return err == nil
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package threshold

import (
        "fmt"

        "github.com/alenon/gokanon/internal/models"
)

// Result represents the result of a threshold check
type Result struct {
        Passed       bool
        Failures     []Failure
        TotalChecked int
}

// Failure represents a benchmark that failed the threshold check
type Failure struct {
        BenchmarkName string
        DeltaPercent  float64
        Threshold     float64
        Message       string
}

// Checker handles threshold checking for benchmarks
type Checker struct {
        maxDegradation float64 // Maximum allowed performance degradation (%)
}

// NewChecker creates a new threshold checker
func NewChecker(maxDegradation float64) *Checker <span class="cov8" title="7">{
        return &amp;Checker{
                maxDegradation: maxDegradation,
        }
}</span>

// Check checks if the comparisons meet the threshold requirements
func (c *Checker) Check(comparisons []models.Comparison) *Result <span class="cov8" title="8">{
        result := &amp;Result{
                Passed:       true,
                TotalChecked: len(comparisons),
        }

        for _, comp := range comparisons </span><span class="cov10" title="12">{
                // Check if performance degraded beyond threshold
                if comp.DeltaPercent &gt; c.maxDegradation </span><span class="cov4" title="3">{
                        result.Passed = false
                        result.Failures = append(result.Failures, Failure{
                                BenchmarkName: comp.Name,
                                DeltaPercent:  comp.DeltaPercent,
                                Threshold:     c.maxDegradation,
                                Message: fmt.Sprintf(
                                        "Performance degraded by %.2f%% (threshold: %.2f%%)",
                                        comp.DeltaPercent,
                                        c.maxDegradation,
                                ),
                        })
                }</span>
        }

        <span class="cov8" title="8">return result</span>
}

// FormatResult formats the threshold check result for display
func FormatResult(result *Result) string <span class="cov3" title="2">{
        if result.Passed </span><span class="cov1" title="1">{
                return fmt.Sprintf(" All %d benchmarks passed the threshold check", result.TotalChecked)
        }</span>

        <span class="cov1" title="1">output := fmt.Sprintf(" %d/%d benchmarks failed the threshold check:\n\n",
                len(result.Failures), result.TotalChecked)

        for _, failure := range result.Failures </span><span class="cov3" title="2">{
                output += fmt.Sprintf("   %s: %s\n", failure.BenchmarkName, failure.Message)
        }</span>

        <span class="cov1" title="1">return output</span>
}

// ExitCode returns the appropriate exit code for CI/CD
func (r *Result) ExitCode() int <span class="cov3" title="2">{
        if r.Passed </span><span class="cov1" title="1">{
                return 0
        }</span>
        <span class="cov1" title="1">return 1</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package ui

import (
        "fmt"
        "os"

        "github.com/fatih/color"
)

var (
        // Disable colors if NO_COLOR environment variable is set or not a TTY
        NoColor = os.Getenv("NO_COLOR") != "" || !isTerminal()

        // Color functions
        Success = color.New(color.FgGreen, color.Bold).SprintFunc()
        Error   = color.New(color.FgRed, color.Bold).SprintFunc()
        Warning = color.New(color.FgYellow, color.Bold).SprintFunc()
        Info    = color.New(color.FgCyan).SprintFunc()
        Dim     = color.New(color.Faint).SprintFunc()
        Bold    = color.New(color.Bold).SprintFunc()

        // Status indicators
        SuccessIcon = ""
        ErrorIcon   = ""
        WarningIcon = ""
        InfoIcon    = ""
        ArrowIcon   = ""

        // Trend indicators
        UpArrow    = ""
        DownArrow  = ""
        RightArrow = ""

        // Emoji indicators (for enhanced output)
        FireEmoji   = ""
        TargetEmoji = ""
        RocketEmoji = ""
        ChartEmoji  = ""
        CheckEmoji  = ""
        CrossEmoji  = ""
)

func init() <span class="cov1" title="1">{
        if NoColor </span><span class="cov1" title="1">{
                color.NoColor = true
        }</span>
}

// isTerminal checks if stdout is a terminal
func isTerminal() bool <span class="cov1" title="1">{
        fileInfo, _ := os.Stdout.Stat()
        return (fileInfo.Mode() &amp; os.ModeCharDevice) != 0
}</span>

// PrintSuccess prints a success message with a green checkmark
func PrintSuccess(format string, args ...interface{}) <span class="cov2" title="2">{
        fmt.Printf("%s %s\n", Success(SuccessIcon), fmt.Sprintf(format, args...))
}</span>

// PrintError prints an error message with a red X
func PrintError(format string, args ...interface{}) <span class="cov1" title="1">{
        fmt.Fprintf(os.Stderr, "%s %s\n", Error(ErrorIcon), fmt.Sprintf(format, args...))
}</span>

// PrintWarning prints a warning message with a yellow warning sign
func PrintWarning(format string, args ...interface{}) <span class="cov1" title="1">{
        fmt.Printf("%s %s\n", Warning(WarningIcon), fmt.Sprintf(format, args...))
}</span>

// PrintInfo prints an info message with a cyan info icon
func PrintInfo(format string, args ...interface{}) <span class="cov1" title="1">{
        fmt.Printf("%s %s\n", Info(InfoIcon), fmt.Sprintf(format, args...))
}</span>

// PrintHeader prints a bold header
func PrintHeader(text string) <span class="cov1" title="1">{
        fmt.Println()
        fmt.Println(Bold(text))
        fmt.Println(Dim(repeatChar("", len(text))))
}</span>

// PrintSection prints a section header
func PrintSection(emoji, title string) <span class="cov1" title="1">{
        fmt.Printf("\n%s %s\n", emoji, Bold(title))
}</span>

// FormatChange formats a performance change with appropriate color
func FormatChange(percentChange float64) string <span class="cov2" title="3">{
        if percentChange &gt; 0 </span><span class="cov1" title="1">{
                return Error(fmt.Sprintf("+%.2f%%", percentChange))
        }</span> else<span class="cov2" title="2"> if percentChange &lt; 0 </span><span class="cov1" title="1">{
                return Success(fmt.Sprintf("%.2f%%", percentChange))
        }</span>
        <span class="cov1" title="1">return Dim(fmt.Sprintf("%.2f%%", percentChange))</span>
}

// FormatDuration formats a duration with color based on magnitude
func FormatDuration(ns float64) string <span class="cov3" title="4">{
        if ns &lt; 1000 </span><span class="cov1" title="1">{
                return Info(fmt.Sprintf("%.2f ns", ns))
        }</span> else<span class="cov2" title="3"> if ns &lt; 1000000 </span><span class="cov1" title="1">{
                return Info(fmt.Sprintf("%.2f s", ns/1000))
        }</span> else<span class="cov2" title="2"> if ns &lt; 1000000000 </span><span class="cov1" title="1">{
                return Warning(fmt.Sprintf("%.2f ms", ns/1000000))
        }</span>
        <span class="cov1" title="1">return Error(fmt.Sprintf("%.2f s", ns/1000000000))</span>
}

// FormatBytes formats bytes with appropriate units and color
func FormatBytes(bytes float64) string <span class="cov3" title="4">{
        if bytes &lt; 1024 </span><span class="cov1" title="1">{
                return Info(fmt.Sprintf("%.0f B", bytes))
        }</span> else<span class="cov2" title="3"> if bytes &lt; 1024*1024 </span><span class="cov1" title="1">{
                return Info(fmt.Sprintf("%.2f KB", bytes/1024))
        }</span> else<span class="cov2" title="2"> if bytes &lt; 1024*1024*1024 </span><span class="cov1" title="1">{
                return Warning(fmt.Sprintf("%.2f MB", bytes/(1024*1024)))
        }</span>
        <span class="cov1" title="1">return Error(fmt.Sprintf("%.2f GB", bytes/(1024*1024*1024)))</span>
}

// repeatChar repeats a character n times
func repeatChar(char string, n int) string <span class="cov5" title="17">{
        result := ""
        for i := 0; i &lt; n; i++ </span><span class="cov10" title="407">{
                result += char
        }</span>
        <span class="cov5" title="17">return result</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package ui

import (
        "fmt"
        "os"
        "strings"
)

// ErrorWithSuggestion represents an error with helpful suggestions
type ErrorWithSuggestion struct {
        Message     string
        Suggestions []string
        Err         error
}

// Error implements the error interface
func (e *ErrorWithSuggestion) Error() string <span class="cov7" title="14">{
        var b strings.Builder
        b.WriteString(Error(ErrorIcon + " " + e.Message))

        if e.Err != nil </span><span class="cov5" title="6">{
                b.WriteString("\n")
                b.WriteString(Dim("  Cause: " + e.Err.Error()))
        }</span>

        <span class="cov7" title="14">if len(e.Suggestions) &gt; 0 </span><span class="cov7" title="12">{
                b.WriteString("\n\n")
                b.WriteString(Info(" Suggestions:"))
                for _, suggestion := range e.Suggestions </span><span class="cov10" title="31">{
                        b.WriteString("\n  " + ArrowIcon + " " + suggestion)
                }</span>
        }

        <span class="cov7" title="14">return b.String()</span>
}

// Unwrap returns the underlying error
func (e *ErrorWithSuggestion) Unwrap() error <span class="cov4" title="4">{
        return e.Err
}</span>

// NewError creates a new error with suggestions
func NewError(message string, err error, suggestions ...string) *ErrorWithSuggestion <span class="cov9" title="23">{
        return &amp;ErrorWithSuggestion{
                Message:     message,
                Suggestions: suggestions,
                Err:         err,
        }
}</span>

// Common error scenarios with suggestions

// ErrNoResults returns an error when no benchmark results are found
func ErrNoResults() error <span class="cov2" title="2">{
        return NewError(
                "No benchmark results found",
                nil,
                "Run 'gokanon run' to create your first benchmark result",
                "Check if .gokanon directory exists in your project",
                "Use 'gokanon doctor' to diagnose any issues",
        )
}</span>

// ErrInvalidRunID returns an error for invalid run IDs
func ErrInvalidRunID(id string, availableIDs []string) error <span class="cov3" title="3">{
        suggestions := []string{
                "Use 'gokanon list' to see all available run IDs",
        }

        if len(availableIDs) &gt; 0 </span><span class="cov1" title="1">{
                suggestions = append(suggestions, fmt.Sprintf("Available runs: %s", strings.Join(availableIDs, ", ")))
        }</span>

        <span class="cov3" title="3">return NewError(
                fmt.Sprintf("Invalid run ID: %s", id),
                nil,
                suggestions...,
        )</span>
}

// ErrBenchmarkFailed returns an error when benchmark execution fails
func ErrBenchmarkFailed(err error) error <span class="cov2" title="2">{
        return NewError(
                "Benchmark execution failed",
                err,
                "Ensure your test files contain valid benchmark functions (func BenchmarkXxx(b *testing.B))",
                "Check that your package compiles: 'go test -c'",
                "Try running with verbose output: 'gokanon run -bench=. -v'",
                "Verify Go toolchain is installed: 'go version'",
        )
}</span>

// ErrInvalidThreshold returns an error for invalid threshold values
func ErrInvalidThreshold(value string) error <span class="cov2" title="2">{
        return NewError(
                fmt.Sprintf("Invalid threshold value: %s", value),
                nil,
                "Threshold must be a positive number (e.g., 10 for 10%)",
                "Use decimal values for fractional percentages (e.g., 2.5 for 2.5%)",
                "Example: 'gokanon check --latest -threshold=10'",
        )
}</span>

// ErrStorageCorrupted returns an error when storage is corrupted
func ErrStorageCorrupted(err error) error <span class="cov2" title="2">{
        return NewError(
                "Benchmark storage appears to be corrupted",
                err,
                "Try running 'gokanon doctor' to diagnose the issue",
                "Backup and remove the .gokanon directory to start fresh",
                "Check file permissions on .gokanon directory",
        )
}</span>

// ErrProfileNotFound returns an error when profile data is missing
func ErrProfileNotFound(runID string) error <span class="cov2" title="2">{
        return NewError(
                fmt.Sprintf("Profile data not found for run: %s", runID),
                nil,
                "Run benchmarks with profiling enabled: 'gokanon run -profile=cpu,mem'",
                "Profiles are only available for runs with -profile flag",
                "Use 'gokanon list' to see which runs have profiles",
        )
}</span>

// ErrInvalidFormat returns an error for unsupported export formats
func ErrInvalidFormat(format string) error <span class="cov2" title="2">{
        return NewError(
                fmt.Sprintf("Unsupported export format: %s", format),
                nil,
                "Supported formats: html, csv, markdown, json",
                "Example: 'gokanon export --latest -format=html'",
        )
}</span>

// ErrPortInUse returns an error when a port is already in use
func ErrPortInUse(port int, err error) error <span class="cov2" title="2">{
        return NewError(
                fmt.Sprintf("Port %d is already in use", port),
                err,
                fmt.Sprintf("Try a different port: 'gokanon serve -port=%d'", port+1),
                "Check running processes: 'lsof -i :%d'",
                "Kill the process using the port or choose a different one",
        )
}</span>

// PrintErrorAndExit prints an error with suggestions and exits
func PrintErrorAndExit(err error, exitCode int) <span class="cov1" title="1">{
        if err == nil </span><span class="cov1" title="1">{
                return
        }</span>

        <span class="cov0" title="0">fmt.Fprintln(os.Stderr, err.Error())
        fmt.Fprintln(os.Stderr)
        os.Exit(exitCode)</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package ui

import (
        "fmt"
        "io"
        "os"
        "sync"
        "time"

        "github.com/schollz/progressbar/v3"
)

// ProgressBar wraps the progressbar library with sensible defaults
type ProgressBar struct {
        bar *progressbar.ProgressBar
}

// NewProgressBar creates a new progress bar
func NewProgressBar(max int, description string) *ProgressBar <span class="cov5" title="12">{
        bar := progressbar.NewOptions(max,
                progressbar.OptionEnableColorCodes(true),
                progressbar.OptionShowBytes(false),
                progressbar.OptionSetWidth(40),
                progressbar.OptionSetDescription(description),
                progressbar.OptionSetTheme(progressbar.Theme{
                        Saucer:        "[green]=[reset]",
                        SaucerHead:    "[green]&gt;[reset]",
                        SaucerPadding: " ",
                        BarStart:      "[",
                        BarEnd:        "]",
                }),
                progressbar.OptionOnCompletion(func() </span><span class="cov4" title="9">{
                        fmt.Println()
                }</span>),
        )

        <span class="cov5" title="12">return &amp;ProgressBar{bar: bar}</span>
}

// NewIndeterminateSpinner creates a spinner for indeterminate operations
func NewIndeterminateSpinner(description string) *ProgressBar <span class="cov1" title="1">{
        bar := progressbar.NewOptions(-1,
                progressbar.OptionSetDescription(description),
                progressbar.OptionSetWidth(10),
                progressbar.OptionSpinnerType(14),
                progressbar.OptionOnCompletion(func() </span><span class="cov1" title="1">{
                        fmt.Println()
                }</span>),
        )

        <span class="cov1" title="1">return &amp;ProgressBar{bar: bar}</span>
}

// Add increments the progress bar
func (p *ProgressBar) Add(num int) error <span class="cov5" title="14">{
        return p.bar.Add(num)
}</span>

// Set sets the progress bar to a specific value
func (p *ProgressBar) Set(num int) error <span class="cov5" title="11">{
        return p.bar.Set(num)
}</span>

// Finish completes the progress bar
func (p *ProgressBar) Finish() error <span class="cov5" title="11">{
        return p.bar.Finish()
}</span>

// Clear clears the progress bar
func (p *ProgressBar) Clear() error <span class="cov1" title="1">{
        return p.bar.Clear()
}</span>

// Describe updates the description
func (p *ProgressBar) Describe(description string) <span class="cov3" title="4">{
        p.bar.Describe(description)
}</span>

// Spinner is a simple spinner for long operations
type Spinner struct {
        writer      io.Writer
        message     string
        stopChan    chan bool
        isRunning   bool
        spinChars   []string
        currentChar int
        mu          sync.RWMutex // Protects message field
}

// isCI checks if we're running in a CI environment
func isCI() bool <span class="cov6" title="24">{
        // Check common CI environment variables
        ciVars := []string{
                "CI",
                "CONTINUOUS_INTEGRATION",
                "GITHUB_ACTIONS",
                "GITLAB_CI",
                "CIRCLECI",
                "TRAVIS",
                "JENKINS_URL",
                "BUILDKITE",
                "DRONE",
        }

        for _, v := range ciVars </span><span class="cov10" title="216">{
                if os.Getenv(v) != "" </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov6" title="24">return false</span>
}

// NewSpinner creates a new spinner
func NewSpinner(message string) *Spinner <span class="cov5" title="16">{
        return &amp;Spinner{
                writer:    os.Stdout,
                message:   message,
                stopChan:  make(chan bool),
                spinChars: []string{"", "", "", "", "", "", "", "", "", ""},
        }
}</span>

// Start starts the spinner
func (s *Spinner) Start() <span class="cov5" title="13">{
        if s.isRunning </span><span class="cov1" title="1">{
                return
        }</span>

        <span class="cov5" title="12">s.isRunning = true

        // In CI environments, just print once without spinning
        if isCI() </span><span class="cov0" title="0">{
                s.mu.RLock()
                msg := s.message
                s.mu.RUnlock()
                fmt.Fprintf(s.writer, "%s %s %s\n",
                        Info(""),
                        msg,
                        Dim("..."))
                return
        }</span>

        <span class="cov5" title="12">go func() </span><span class="cov5" title="12">{
                ticker := time.NewTicker(100 * time.Millisecond)
                defer ticker.Stop()

                for </span><span class="cov6" title="34">{
                        select </span>{
                        case &lt;-s.stopChan:<span class="cov5" title="12">
                                return</span>
                        case &lt;-ticker.C:<span class="cov6" title="22">
                                s.mu.RLock()
                                msg := s.message
                                s.mu.RUnlock()

                                fmt.Fprintf(s.writer, "\r%s %s %s",
                                        Info(s.spinChars[s.currentChar]),
                                        msg,
                                        Dim("..."))
                                s.currentChar = (s.currentChar + 1) % len(s.spinChars)</span>
                        }
                }
        }()
}

// Stop stops the spinner
func (s *Spinner) Stop() <span class="cov5" title="14">{
        if !s.isRunning </span><span class="cov2" title="2">{
                return
        }</span>

        // In CI, we just printed once, so nothing to clean up
        <span class="cov5" title="12">if isCI() </span><span class="cov0" title="0">{
                s.isRunning = false
                return
        }</span>

        <span class="cov5" title="12">s.stopChan &lt;- true
        s.isRunning = false

        s.mu.RLock()
        msgLen := len(s.message)
        s.mu.RUnlock()

        fmt.Fprintf(s.writer, "\r%s\r", repeatChar(" ", msgLen+20))</span>
}

// UpdateMessage updates the spinner message
func (s *Spinner) UpdateMessage(message string) <span class="cov2" title="2">{
        s.mu.Lock()
        s.message = message
        s.mu.Unlock()
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package webserver

import (
        "bytes"
        "fmt"
        "html/template"
        "net/http"
        "os"
        "os/exec"
        "path/filepath"
        "strings"

        "github.com/alenon/gokanon/internal/models"
        "github.com/alenon/gokanon/internal/storage"
        "github.com/google/pprof/profile"
)

// Server handles web serving of profile visualizations
type Server struct {
        storage *storage.Storage
        port    string
}

// NewServer creates a new web server
func NewServer(store *storage.Storage, port string) *Server <span class="cov10" title="12">{
        return &amp;Server{
                storage: store,
                port:    port,
        }
}</span>

// Start starts the web server
func (s *Server) Start(runID string) error <span class="cov0" title="0">{
        // Load the benchmark run
        run, err := s.storage.Load(runID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load run: %w", err)
        }</span>

        <span class="cov0" title="0">if run.CPUProfile == "" &amp;&amp; run.MemoryProfile == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("no profiles found for run %s", runID)
        }</span>

        // Setup HTTP handlers
        <span class="cov0" title="0">mux := http.NewServeMux()

        // Main page
        mux.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                s.handleIndex(w, r, run)
        }</span>)

        // CPU profile visualization
        <span class="cov0" title="0">if run.CPUProfile != "" </span><span class="cov0" title="0">{
                mux.HandleFunc("/cpu", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        s.handleProfile(w, r, run.CPUProfile, "CPU Profile")
                }</span>)
                <span class="cov0" title="0">mux.HandleFunc("/cpu/flamegraph", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        s.handleFlameGraph(w, r, run.CPUProfile, "CPU")
                }</span>)
        }

        // Memory profile visualization
        <span class="cov0" title="0">if run.MemoryProfile != "" </span><span class="cov0" title="0">{
                mux.HandleFunc("/mem", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        s.handleProfile(w, r, run.MemoryProfile, "Memory Profile")
                }</span>)
                <span class="cov0" title="0">mux.HandleFunc("/mem/flamegraph", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        s.handleFlameGraph(w, r, run.MemoryProfile, "Memory")
                }</span>)
        }

        // Profile comparison
        <span class="cov0" title="0">if run.CPUProfile != "" &amp;&amp; run.MemoryProfile != "" </span><span class="cov0" title="0">{
                mux.HandleFunc("/compare", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        s.handleCompare(w, r, run)
                }</span>)
        }

        // Static assets (if needed)
        <span class="cov0" title="0">mux.HandleFunc("/static/", s.handleStatic)

        addr := ":" + s.port
        fmt.Printf("Starting profile visualization server at http://localhost%s\n", addr)
        fmt.Println("Press Ctrl+C to stop")

        return http.ListenAndServe(addr, mux)</span>
}

// handleIndex shows the main page with links to different views
func (s *Server) handleIndex(w http.ResponseWriter, r *http.Request, run *models.BenchmarkRun) <span class="cov4" title="3">{
        if r.URL.Path != "/" </span><span class="cov1" title="1">{
                http.NotFound(w, r)
                return
        }</span>

        // Create template with custom functions
        <span class="cov3" title="2">funcMap := template.FuncMap{
                "div": func(a, b float64) float64 </span><span class="cov0" title="0">{
                        if b == 0 </span><span class="cov0" title="0">{
                                return 0
                        }</span>
                        <span class="cov0" title="0">return a / b</span>
                },
                "float64": func(i int64) float64 <span class="cov0" title="0">{
                        return float64(i)
                }</span>,
        }

        <span class="cov3" title="2">tmpl := template.Must(template.New("index").Funcs(funcMap).Parse(indexTemplate))
        data := struct {
                Run        *models.BenchmarkRun
                HasCPU     bool
                HasMemory  bool
                HasSummary bool
        }{
                Run:        run,
                HasCPU:     run.CPUProfile != "",
                HasMemory:  run.MemoryProfile != "",
                HasSummary: run.ProfileSummary != nil,
        }

        w.Header().Set("Content-Type", "text/html; charset=utf-8")
        tmpl.Execute(w, data)</span>
}

// handleProfile serves pprof profile visualization
func (s *Server) handleProfile(w http.ResponseWriter, r *http.Request, profilePath, title string) <span class="cov3" title="2">{
        // Read profile file
        data, err := os.ReadFile(profilePath)
        if err != nil </span><span class="cov1" title="1">{
                http.Error(w, fmt.Sprintf("Failed to read profile: %v", err), http.StatusInternalServerError)
                return
        }</span>

        // Serve using pprof handler
        <span class="cov1" title="1">w.Header().Set("Content-Type", "application/octet-stream")
        w.Header().Set("Content-Disposition", fmt.Sprintf("attachment; filename=%s.prof", strings.ToLower(title)))
        w.Write(data)</span>
}

// handleFlameGraph generates and serves a flame graph
func (s *Server) handleFlameGraph(w http.ResponseWriter, r *http.Request, profilePath, profileType string) <span class="cov3" title="2">{
        // Check if profile exists
        if _, err := os.Stat(profilePath); err != nil </span><span class="cov1" title="1">{
                http.Error(w, fmt.Sprintf("Profile not found: %v", err), http.StatusNotFound)
                return
        }</span>

        // Try to generate SVG using go tool pprof
        <span class="cov1" title="1">cmd := exec.Command("go", "tool", "pprof", "-http=:", "-no_browser", profilePath)
        var stdout, stderr bytes.Buffer
        cmd.Stdout = &amp;stdout
        cmd.Stderr = &amp;stderr

        // Generate a simple visualization using go tool pprof
        // For a basic flame graph, we'll generate the top output
        cmd = exec.Command("go", "tool", "pprof", "-top", "-cum", profilePath)
        output, err := cmd.CombinedOutput()

        if err != nil </span><span class="cov0" title="0">{
                // Fallback to simple visualization
                s.handleSimpleVisualization(w, profilePath, profileType)
                return
        }</span>

        // Display as formatted text
        <span class="cov1" title="1">tmpl := template.Must(template.New("flamegraph").Parse(flamegraphTemplate))
        w.Header().Set("Content-Type", "text/html; charset=utf-8")
        tmpl.Execute(w, map[string]interface{}{
                "Type":    profileType,
                "Content": string(output),
                "Path":    profilePath,
        })</span>
}

// handleSimpleVisualization provides a fallback text-based visualization
func (s *Server) handleSimpleVisualization(w http.ResponseWriter, profilePath, profileType string) <span class="cov1" title="1">{
        data, err := os.ReadFile(profilePath)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, fmt.Sprintf("Failed to read profile: %v", err), http.StatusInternalServerError)
                return
        }</span>

        // Parse the profile using google pprof
        <span class="cov1" title="1">prof, err := profile.Parse(bytes.NewReader(data))
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, fmt.Sprintf("Failed to parse profile: %v", err), http.StatusInternalServerError)
                return
        }</span>

        // Generate a simple text summary
        <span class="cov1" title="1">var summary strings.Builder
        summary.WriteString(fmt.Sprintf("Profile: %s\n", profileType))
        summary.WriteString(fmt.Sprintf("Sample Type: %v\n", prof.SampleType))
        summary.WriteString(fmt.Sprintf("Samples: %d\n\n", len(prof.Sample)))

        tmpl := template.Must(template.New("profile").Parse(profileTemplate))
        w.Header().Set("Content-Type", "text/html; charset=utf-8")
        tmpl.Execute(w, map[string]interface{}{
                "Type":    profileType,
                "Profile": summary.String(),
        })</span>
}

// handleCompare shows side-by-side profile comparison
func (s *Server) handleCompare(w http.ResponseWriter, r *http.Request, run *models.BenchmarkRun) <span class="cov1" title="1">{
        tmpl := template.Must(template.New("compare").Parse(compareTemplate))
        w.Header().Set("Content-Type", "text/html; charset=utf-8")
        tmpl.Execute(w, run)
}</span>

// handleStatic serves static assets
func (s *Server) handleStatic(w http.ResponseWriter, r *http.Request) <span class="cov1" title="1">{
        path := r.URL.Path[len("/static/"):]
        http.ServeFile(w, r, filepath.Join("static", path))
}</span>

// HTML templates
const flamegraphTemplate = `&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;{{.Type}} Profile&lt;/title&gt;
    &lt;style&gt;
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, monospace;
            margin: 0;
            padding: 20px;
            background: #1e1e1e;
            color: #d4d4d4;
        }
        .header {
            background: #2d2d30;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        h1 {
            margin: 0;
            color: #fff;
        }
        .actions {
            margin-top: 10px;
        }
        .btn {
            display: inline-block;
            padding: 8px 16px;
            background: #007acc;
            color: white;
            text-decoration: none;
            border-radius: 4px;
            margin-right: 10px;
        }
        .btn:hover {
            background: #005a9e;
        }
        pre {
            background: #2d2d30;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            white-space: pre;
            font-family: 'Courier New', Courier, monospace;
            font-size: 13px;
            line-height: 1.5;
        }
        .hint {
            background: #3e3e42;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border-left: 4px solid #007acc;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class="header"&gt;
        &lt;h1&gt;{{.Type}} Profile&lt;/h1&gt;
        &lt;div class="actions"&gt;
            &lt;a href="/" class="btn"&gt; Back to Overview&lt;/a&gt;
            &lt;a href="{{.Path}}" class="btn"&gt;Download Profile&lt;/a&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class="hint"&gt;
        &lt;strong&gt; Tip:&lt;/strong&gt; For interactive flame graphs, download the profile and use:&lt;br&gt;
        &lt;code&gt;go tool pprof -http=:8080 {{.Path}}&lt;/code&gt;
    &lt;/div&gt;

    &lt;pre&gt;{{.Content}}&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;`

const indexTemplate = `&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Profile Viewer - {{.Run.ID}}&lt;/title&gt;
    &lt;style&gt;
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .header {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        h1 {
            margin: 0;
            color: #333;
        }
        .meta {
            color: #666;
            margin-top: 10px;
        }
        .profiles {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        .card {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .card h2 {
            margin-top: 0;
            color: #333;
        }
        .btn {
            display: inline-block;
            padding: 10px 20px;
            background: #007bff;
            color: white;
            text-decoration: none;
            border-radius: 4px;
            margin-right: 10px;
            margin-top: 10px;
        }
        .btn:hover {
            background: #0056b3;
        }
        .summary {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .summary h2 {
            margin-top: 0;
        }
        .summary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        .stat {
            padding: 15px;
            background: #f8f9fa;
            border-radius: 4px;
            border-left: 4px solid #007bff;
        }
        .stat-label {
            font-size: 12px;
            color: #666;
            text-transform: uppercase;
        }
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #333;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class="header"&gt;
        &lt;h1&gt; Profile Viewer&lt;/h1&gt;
        &lt;div class="meta"&gt;
            &lt;strong&gt;Run ID:&lt;/strong&gt; {{.Run.ID}}&lt;br&gt;
            &lt;strong&gt;Timestamp:&lt;/strong&gt; {{.Run.Timestamp.Format "2006-01-02 15:04:05"}}&lt;br&gt;
            &lt;strong&gt;Package:&lt;/strong&gt; {{.Run.Package}}&lt;br&gt;
            &lt;strong&gt;Duration:&lt;/strong&gt; {{.Run.Duration}}
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class="profiles"&gt;
        {{if .HasCPU}}
        &lt;div class="card"&gt;
            &lt;h2&gt; CPU Profile&lt;/h2&gt;
            &lt;p&gt;Analyze where your code spends time during execution.&lt;/p&gt;
            &lt;a href="/cpu/flamegraph" class="btn"&gt;View Flame Graph&lt;/a&gt;
            &lt;a href="/cpu" class="btn"&gt;Download Profile&lt;/a&gt;
        &lt;/div&gt;
        {{end}}

        {{if .HasMemory}}
        &lt;div class="card"&gt;
            &lt;h2&gt; Memory Profile&lt;/h2&gt;
            &lt;p&gt;Identify memory allocations and potential leaks.&lt;/p&gt;
            &lt;a href="/mem/flamegraph" class="btn"&gt;View Flame Graph&lt;/a&gt;
            &lt;a href="/mem" class="btn"&gt;Download Profile&lt;/a&gt;
        &lt;/div&gt;
        {{end}}

        {{if and .HasCPU .HasMemory}}
        &lt;div class="card"&gt;
            &lt;h2&gt; Comparison&lt;/h2&gt;
            &lt;p&gt;View CPU and memory profiles side-by-side.&lt;/p&gt;
            &lt;a href="/compare" class="btn"&gt;Compare Profiles&lt;/a&gt;
        &lt;/div&gt;
        {{end}}
    &lt;/div&gt;

    {{if .HasSummary}}
    &lt;div class="summary"&gt;
        &lt;h2&gt; Profile Summary&lt;/h2&gt;
        &lt;div class="summary-grid"&gt;
            {{if .Run.ProfileSummary.TotalCPUSamples}}
            &lt;div class="stat"&gt;
                &lt;div class="stat-label"&gt;CPU Samples&lt;/div&gt;
                &lt;div class="stat-value"&gt;{{.Run.ProfileSummary.TotalCPUSamples}}&lt;/div&gt;
            &lt;/div&gt;
            {{end}}
            {{if .Run.ProfileSummary.TotalMemoryBytes}}
            &lt;div class="stat"&gt;
                &lt;div class="stat-label"&gt;Memory Allocated&lt;/div&gt;
                &lt;div class="stat-value"&gt;{{printf "%.1f MB" (div (float64 .Run.ProfileSummary.TotalMemoryBytes) 1048576)}}&lt;/div&gt;
            &lt;/div&gt;
            {{end}}
            &lt;div class="stat"&gt;
                &lt;div class="stat-label"&gt;Hot Functions&lt;/div&gt;
                &lt;div class="stat-value"&gt;{{len .Run.ProfileSummary.CPUTopFunctions}}&lt;/div&gt;
            &lt;/div&gt;
            &lt;div class="stat"&gt;
                &lt;div class="stat-label"&gt;Suggestions&lt;/div&gt;
                &lt;div class="stat-value"&gt;{{len .Run.ProfileSummary.Suggestions}}&lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    {{end}}
&lt;/body&gt;
&lt;/html&gt;`

const profileTemplate = `&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;{{.Type}} Profile&lt;/title&gt;
    &lt;style&gt;
        body {
            font-family: monospace;
            padding: 20px;
            background: #1e1e1e;
            color: #d4d4d4;
        }
        pre {
            white-space: pre-wrap;
            word-wrap: break-word;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;{{.Type}} Profile&lt;/h1&gt;
    &lt;pre&gt;{{.Profile}}&lt;/pre&gt;
&lt;/body&gt;
&lt;/html&gt;`

const compareTemplate = `&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Profile Comparison&lt;/title&gt;
    &lt;style&gt;
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 0;
        }
        .container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            height: 100vh;
        }
        .pane {
            padding: 20px;
            overflow: auto;
        }
        .pane h2 {
            margin-top: 0;
        }
        .left {
            border-right: 2px solid #ccc;
        }
        iframe {
            width: 100%;
            height: calc(100% - 60px);
            border: none;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class="container"&gt;
        &lt;div class="pane left"&gt;
            &lt;h2&gt; CPU Profile&lt;/h2&gt;
            &lt;iframe src="/cpu/flamegraph"&gt;&lt;/iframe&gt;
        &lt;/div&gt;
        &lt;div class="pane"&gt;
            &lt;h2&gt; Memory Profile&lt;/h2&gt;
            &lt;iframe src="/mem/flamegraph"&gt;&lt;/iframe&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;`
</pre>
		
		<pre class="file" id="file32" style="display: none">package main

import (
        "fmt"
        "os"

        "github.com/alenon/gokanon/internal/cli"
)

func main() <span class="cov0" title="0">{
        if err := cli.Execute(); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error: %v\n", err)
                os.Exit(1)
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
